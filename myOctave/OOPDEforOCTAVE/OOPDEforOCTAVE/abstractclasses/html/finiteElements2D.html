
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>finiteElements2D</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-12-16"><meta name="DC.source" content="finiteElements2D.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>finiteElements2D</h1><!--introduction--><p>Abstract class to build Finite Elements for 2D domains.</p><pre class="codeoutput error">Abstract classes cannot be instantiated.  Class 'finiteElements2D' defines abstract methods and/or properties.
</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Copy style</a></li><li><a href="#2">Inheritance</a></li><li><a href="#3">assembDataRobin</a></li></ul></div><h2 id="1">Copy style</h2><p>handle</p><h2 id="2">Inheritance</h2><p>finiteElements2D &lt; finiteElements &lt; handle</p><pre class="codeinput"><span class="keyword">classdef</span> (Abstract) finiteElements2D &lt; finiteElements
    <span class="keyword">properties</span>(Abstract = true,<span class="keyword">...</span>
            Constant = true,<span class="keyword">...</span>
            Access = protected)
        boundaryElements
        <span class="comment">% Defines the boundary elements for assembling the boundary</span>
        <span class="comment">% condtion.</span>
    <span class="keyword">end</span>

    <span class="keyword">properties</span>(Abstract = true, Constant = true, Access = public)
        <span class="comment">% The order of point indices in the e field. Trivialy [1,2] for P1</span>
        <span class="comment">% elements but important for extended meshes.</span>
        boundaryIndex
    <span class="keyword">end</span>

    <span class="keyword">methods</span>(Access = public)
        <span class="keyword">function</span> [K,M,F] = createMatrixEntries(obj,gridObj,cf,af,ff)
            <span class="comment">% the sizes of elementary matrices, varies from element</span>
            <span class="comment">% type to element type...</span>
            <span class="comment">% The space needed by sparse methods. Note that S1 etc are</span>
            <span class="comment">% stored as vectors. It length is 9 in the case of linear</span>
            <span class="comment">% Elements on triangles but it can vary</span>
            sizeVector = sqrt(size(obj.S1,1));
            sizeMatrix = size(obj.S1,1);

            <span class="comment">% compute the coefficients. The result is always a k x nElelemts</span>
            <span class="comment">% matrix where k = 4 for c, k = 1 for a and f.</span>
            [cval,aval,fval] = obj.aCoefficients(gridObj,cf,af,ff);

            <span class="comment">% We obtain the Matrices from the exact integration multiplied</span>
            <span class="comment">% by the grid-dependent but for fix grid constant</span>
            <span class="comment">% transformations.</span>
            [K1,K12,K2] = obj.getConstantPartOfStiffnessMatrix(gridObj);
            <span class="comment">% Now we have to multiply the Ks by c(1) and c(2).</span>
            <span class="comment">% For the mixed derivatives, this code must be EXTENDED.</span>
            K = reshape(<span class="keyword">...</span>
                K1*sparse(1:gridObj.nElements,1:gridObj.nElements,<span class="keyword">...</span>
                cval(1,:))+ K2*sparse(1:gridObj.nElements,1:gridObj.nElements,<span class="keyword">...</span>
                cval(4,:))+ K12*sparse(1:gridObj.nElements,1:gridObj.nElements,<span class="keyword">...</span>
                cval(3,:)+cval(2,:)),<span class="keyword">...</span>
                1,<span class="keyword">...</span>
                gridObj.nElements*sizeMatrix);

            M = reshape(obj.M*(aval.*obj.makeJ(gridObj)),<span class="keyword">...</span>
                1,<span class="keyword">...</span>
                gridObj.nElements*sizeMatrix);

            F = reshape(obj.F*(obj.makeJ(gridObj).*fval),1,<span class="keyword">...</span>
                gridObj.nElements*sizeVector);
        <span class="keyword">end</span>

        <span class="keyword">function</span> val = createConvectionEntries(obj,gridObj,b)
            <span class="comment">% the point of the triagles</span>
            p1 = gridObj.p(:,(gridObj.t(1,:)));
            p2 = gridObj.p(:,(gridObj.t(2,:)));
            p3 = gridObj.p(:,(gridObj.t(3,:)));
            <span class="comment">% get element corner coordinates</span>
            x21 = p2(1,:)-p1(1,:);
            x31 = p3(1,:)-p1(1,:);
            y21 = p2(2,:)-p1(2,:);
            y31 = p3(2,:)-p1(2,:);
            bval = obj.convCoefficients(gridObj,b);
            J1 = bval(:,1)'.*y31-bval(:,2)'.*x31;
            J2 = bval(:,2)'.*x21-bval(:,1)'.*y21;
            <span class="comment">% This works for P1 and P2 etc. elements, really</span>
            val = reshape(obj.C1*J1+obj.C2*J2,1,gridObj.nElements*size(obj.C1,1));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>(Access = public,Hidden)
        <span class="keyword">function</span> [K1,K12,K2] = getConstantPartOfStiffnessMatrix(obj,gridObj)
            <span class="comment">% Needed by createMatrixEntries</span>
            <span class="comment">% helper method to compute the former abstract J</span>
            <span class="comment">%</span>
            p1 = gridObj.p(:,(gridObj.t(1,:)));
            p2 = gridObj.p(:,(gridObj.t(2,:)));
            p3 = gridObj.p(:,(gridObj.t(3,:)));

            <span class="comment">% get element corner coordinates</span>
            x21 = p2(1,:)-p1(1,:);
            x31 = p3(1,:)-p1(1,:);

            y21 = p2(2,:)-p1(2,:);
            y31 = p3(2,:)-p1(2,:);

            <span class="comment">% now we compute J for every element in one operation</span>
            J = obj.makeJ(gridObj) ;
            <span class="comment">% Inversion by using the famous 2x2 inversion formula, but with</span>
            <span class="comment">% out division by J: A few lines later we compute e.g.</span>
            <span class="comment">% xi_x^2*j so we can "correct" this "mistake"  here.</span>
            xi_x  =  y31;
            eta_x = -y21;
            xi_y = -x31;
            eta_y = x21;

            K1 = obj.S1*((xi_x.^2)./J) + obj.S3*((eta_x.^2)./J)<span class="keyword">...</span>
                +  obj.S2*((xi_x.*eta_x)./J);

            K2 = obj.S1*((xi_y.^2)./J) + obj.S3*((eta_y.^2)./J)<span class="keyword">...</span>
                +  obj.S2*((xi_y.*eta_y)./J);
            <span class="comment">% The following will work only for symmetric matrices.</span>
            K12 = obj.S1*((xi_y.*xi_x)./J) + obj.S3*((eta_y.*eta_x)./J)<span class="keyword">...</span>
                +  obj.S2*((xi_y.*eta_x+ xi_x.*eta_y )./J/2);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>(Static,Access=protected)
        <span class="keyword">function</span> [cval,aval,fval] =  aCoefficients(gridObj,cc,aa,ff)
            [cval,aval,fval] = gridObj.aCoefficientsMpt(cc,aa,ff);
        <span class="keyword">end</span>

        <span class="keyword">function</span> bval = convCoefficients(gridObj,b)
            bval = gridObj.convCoefficientsMpt(b);
        <span class="keyword">end</span>

        <span class="keyword">function</span> J = makeJ(gridObj)
            <span class="comment">% compute Jacobi determinat</span>
            <span class="keyword">if</span> ~(isa(gridObj,<span class="string">'grid2D'</span>)||isa(gridObj,<span class="string">'grid2DR'</span>))
                gridObj.wrongClass.throwAsCaller;
            <span class="keyword">end</span>
            <span class="comment">%heim_neu</span>
            <span class="keyword">if</span> gridObj.isExtended
                p = gridObj.p(:,1:gridObj.NrPO);
            <span class="keyword">else</span>
                p = gridObj.p;
            <span class="keyword">end</span>
            <span class="comment">% end heim_neu</span>
            t = gridObj.t;
            p1 = p(:,(t(1,:)));
            p2 = p(:,(t(2,:)));
            p3 = p(:,(t(3,:)));
            x21 = p2(1,:)-p1(1,:);
            x31 = p3(1,:)-p1(1,:);
            y21 = p2(2,:)-p1(2,:);
            y31 = p3(2,:)-p1(2,:);
            J = x21.*y31-x31.*y21;
        <span class="keyword">end</span>


        <span class="comment">%Implement abstract inheritance from finiteElements class</span>
        <span class="keyword">function</span> ddncu = fluxThroughEdges(obj,u,c)
            <span class="comment">% fluxThroughEdges Fluxes of -div(c grad(u))</span>
            <span class="comment">% through edges of triangles.</span>
            <span class="comment">% ddncu = obj.fluxThroughEdges(grid,u,c)</span>


            <span class="comment">% Arguments check:</span>
            <span class="keyword">switch</span> length(c)
                <span class="keyword">case</span> {1, obj.nElements}
                    <span class="comment">% c fits!</span>
                <span class="keyword">case</span> obj.nPoints
                    c = obj.point2Center(c);
                <span class="keyword">otherwise</span>
                    <span class="comment">% c is miss-dimensioned</span>
                    obj.wrongFormat.throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">if</span> length(u)~=obj.nPoints
                obj.wrongFormat.throwAsCaller;
            <span class="keyword">end</span>


            [sideLength, elementArea] = obj.sideLengthAndArea;


            dx = zeros(3,obj.nElements); dy = zeros(3,obj.nElements);
            <span class="keyword">for</span> k = 1:3
                k1 = rem(k ,3)+1;
                k2 = rem(k1,3)+1;
                dx(k,:) = obj.p(1,obj.t(k1,:)) - obj.p(1,obj.t(k2,:));
                dy(k,:) = obj.p(2,obj.t(k1,:)) - obj.p(2,obj.t(k2,:));
            <span class="keyword">end</span>
            <span class="comment">% gradients of basis functions</span>
            g1x=0.5*dy(1,:)./elementArea;
            g2x=0.5*dy(2,:)./elementArea;
            g3x=0.5*dy(3,:)./elementArea;
            g1y=-0.5*dx(1,:)./elementArea;
            g2y=-0.5*dx(2,:)./elementArea;
            g3y=-0.5*dx(3,:)./elementArea;

            <span class="comment">% preparations</span>

            <span class="comment">% select points from triangle</span>
            it1=obj.t(1,:);
            it2=obj.t(2,:);
            it3=obj.t(3,:);

            <span class="comment">% Compute gradient numerically</span>
            <span class="comment">% grad_x</span>
            gradx = u(it1,:).'.*(g1x)+u(it2,:).'.*(g2x)+ <span class="keyword">...</span>
                  u(it3,:).'.*(g3x);

            <span class="comment">% grad_y</span>
            grady = u(it1,:).'.*(g1y)+u(it2,:).'.*(g2y)+ <span class="keyword">...</span>
                  u(it3,:).'.*(g3y);

            <span class="comment">% Compute c * grad u</span>
            nrc=size(c,1);
            cgradx=zeros(1,obj.nElements);
            cgrady=zeros(1,obj.nElements);
            <span class="keyword">if</span> nrc==1
                cgradx(1,:)=c.*gradx(1,:);
                cgrady(1,:)=c.*grady(1,:);
            <span class="keyword">elseif</span> nrc==2
                cgradx(1,:)=c(1,:).*gradx(1,:);
                cgrady(1,:)=c(2,:).*grady(1,:);
            <span class="keyword">elseif</span> nrc==3
                cgradx(1,:)=c(1,:).*gradx(1,:)+c(2,:).*grady(1,:);
                cgrady(1,:)=c(2,:).*gradx(1,:)+c(3,:).*grady(1,:);
            <span class="keyword">elseif</span> nrc==4
                cgradx(1,:)=c(1,:).*gradx(1,:)+c(3,:).*grady(1,:);
                cgrady(1,:)=c(2,:).*gradx(1,:)+c(4,:).*grady(1,:);
            <span class="keyword">else</span>
              MException(obj.wrongInputFormatID,<span class="keyword">...</span>
                    [obj.wrongInputFormatStr,<span class="string">'Wrong format of c.'</span>]).throwAsCaller
            <span class="keyword">end</span>

            <span class="comment">% nhat'*c grad u</span>
            <span class="comment">% edge unit normals : outwards positive if the nodes are in</span>
            <span class="comment">% anti-clockwise order</span>
            <span class="comment">% nhatx =   dy./s;</span>
            <span class="comment">% nhaty = - dx./s;</span>
            ddncu = zeros(3,obj.nElements);
            <span class="keyword">for</span> k = 1:3
                ddncu(k,:) = (dy(k,:).*cgradx(1,:) - dx(k,:).*cgrady(1,:))./sideLength(k,:);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> jumps = fluxJumps(obj,fluxThroughElementEdges,m)
            jumps = zeros(1,obj.nElements);
            [sideLength, ~] = obj.sideLengthAndArea;

            <span class="comment">% --- this is dimension depending -- here 2D triangle</span>
            interiorEdges=sparse(obj.t([2 3 1],:),obj.t([3 1 2],:),1,obj.nPoints,obj.nPoints);
            <span class="comment">% intj+intj.' is 2 if interior edge and 1 if exterior edge</span>

            <span class="comment">% --- Interior only</span>
            interiorEdges=round((interiorEdges+interiorEdges.')/3);



            jmps = sparse(obj.t([2 3 1],:),obj.t([3 1 2],:),<span class="keyword">...</span>
                fluxThroughElementEdges([1 2 3],:),obj.nPoints,obj.nPoints);


            jmps = interiorEdges.*abs(jmps + jmps.');
            <span class="keyword">for</span> l = 1:obj.nElements
                jumps(l) = (sideLength(3,l)^m*abs(jmps(obj.t(1,l),obj.t(2,l))))^2+<span class="keyword">...</span>
                       (sideLength(1,l)^m*abs(jmps(obj.t(2,l),obj.t(3,l))))^2+<span class="keyword">...</span>
                       (sideLength(2,l)^m*abs(jmps(obj.t(3,l),obj.t(1,l))))^2;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>(Access=public,<span class="keyword">...</span>
            Static = true)


        <span class="keyword">function</span> [H,R] = assembDataDirichlet(gridObj,arg1,arg2)

            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1 <span class="comment">% No data given: Assume homogenious Dirichlet Problem</span>
                    arg1 = 1;
                    arg2 = 0;
                <span class="keyword">case</span> 2 <span class="comment">% only R given: Implement h = r</span>
                    arg2 = arg1;
                    arg1 = 1;
                <span class="keyword">case</span> 3
                    <span class="comment">% Nothig to do.</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~(isa(gridObj,<span class="string">'grid2DR'</span>)||isa(gridObj,<span class="string">'grid2D'</span>))
                MException(<span class="string">'BILINEAR3D:WRONGARGS'</span>,<span class="keyword">...</span>
                        <span class="string">'The first argument must be a grid2DR object.'</span>).throwAsCaller;
            <span class="keyword">end</span>

            <span class="comment">% The case of intersecting Dirichlet boundary segments.</span>
            <span class="keyword">if</span> gridObj.nDirichletBoundaryPoints~=<span class="keyword">...</span>
                length(gridObj.indexOfDirichletBoundaryPoints)
                fprintf([<span class="string">'\nWarning: Two or more Dirichlet boundary segments have common points.\n'</span>,<span class="keyword">...</span>
                    <span class="string">'In this case, the boundary value function may be not continuous.\n'</span>,<span class="keyword">...</span>
                    <span class="string">'The value that appears first in the arguments \n'</span>,<span class="keyword">...</span>
                    <span class="string">'will be taken, the second will be ignored.\n\n'</span>]);

                [~,s,~] = unique(gridObj.indexOfDirichletBoundaryPoints,<span class="string">'stable'</span>);

                <span class="keyword">if</span> isscalar(arg1)
                    h = arg1(ones(1,gridObj.nDirichletBoundaryPoints));
                <span class="keyword">else</span>
                    h = arg1(s);
                <span class="keyword">end</span>

                <span class="keyword">if</span> isscalar(arg2)
                    R = arg2(ones(gridObj.nDirichletBoundaryPoints,1));
                <span class="keyword">else</span>
                    R = arg2(s);
                <span class="keyword">end</span>

                H = sparse(1:gridObj.nDirichletBoundaryPoints,<span class="keyword">...</span>
                        gridObj.indexOfDirichletBoundaryPoints(s),<span class="keyword">...</span>
                        h,<span class="keyword">...</span>
                        gridObj.nDirichletBoundaryPoints,<span class="keyword">...</span>
                        gridObj.nPoints);


                R = R(:);
            <span class="keyword">else</span>
                <span class="keyword">if</span> isscalar(arg1)
                    h = arg1(ones(1,gridObj.nDirichletBoundaryPoints));
                <span class="keyword">else</span>
                    h = arg1;
                <span class="keyword">end</span>

                <span class="keyword">if</span> isscalar(arg2)
                    R = arg2(ones(gridObj.nDirichletBoundaryPoints,1));
                <span class="keyword">else</span>
                    R = arg2(:);
                <span class="keyword">end</span>
                H = sparse(1:gridObj.nDirichletBoundaryPoints,<span class="keyword">...</span>
                        gridObj.indexOfDirichletBoundaryPoints,<span class="keyword">...</span>
                        h,<span class="keyword">...</span>
                        gridObj.nDirichletBoundaryPoints,<span class="keyword">...</span>
                        gridObj.nPoints);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>(Access=public)
        <span class="keyword">function</span> [Q,G] = assembDataRobin(obj,gridObj,arg1,arg2)
</pre><h2 id="3">assembDataRobin</h2><pre>IN:self, grid2DR,double[,double] OUT:double,double</pre><p>Assembles matrix Q and G from data vectors. Arguments are the grid, the data g (Neumann BC) or q and g.</p><p>The data vectors must contain the value of q(x) and g(x) respectivelly in the barycenters of the boundary elements, triangle or sqares, respectivelly.</p><p>The order of the data must be the order of elements in obj.e. of the Robin and/or Neumann baundary conditions.</p><pre class="codeinput">            <span class="comment">% prepare and test data.</span>

            <span class="comment">% Since the boundary elements in the boundary  segments are not</span>
            <span class="comment">% increasing we resort the data.</span>
            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 3 <span class="comment">% Only g given: Neumann boudarys</span>
                    g = arg1;
                    <span class="keyword">if</span> isscalar(g)
                        g = g(ones(1,gridObj.nRobinBoundaryElements));
                    <span class="keyword">elseif</span> isvector(g)&amp;&amp;length(g)==gridObj.nRobinBoundaryElements
                            <span class="comment">%  okay</span>
                    <span class="keyword">else</span>
                        gridObj.wrongFormat.throwAsCaller;
                    <span class="keyword">end</span>
                    q = zeros(1,gridObj.nRobinBoundaryElements);
                <span class="keyword">case</span> 4
                    g = arg2;
                    <span class="keyword">if</span> isscalar(g)
                        g = g(ones(1,gridObj.nRobinBoundaryElements));
                    <span class="keyword">elseif</span> isvector(g)&amp;&amp;length(g)==gridObj.nRobinBoundaryElements
                        <span class="comment">%  okay</span>
                    <span class="keyword">else</span>
                        gridObj.wrongFormat.throwAsCaller;
                    <span class="keyword">end</span>
                    q = arg1;
                    <span class="keyword">if</span> isscalar(q)
                        q = q(ones(1,gridObj.nRobinBoundaryElements));
                    <span class="keyword">elseif</span> isvector(q)&amp;&amp;length(q)==gridObj.nRobinBoundaryElements
                         <span class="comment">% okay</span>
                    <span class="keyword">else</span>
                        gridObj.wrongFormat.throwAsCaller;
                    <span class="keyword">end</span>

                <span class="keyword">otherwise</span> <span class="comment">%</span>
                    MException(<span class="string">'BILINEAR3D:WRONGNUMBERARGS'</span>,<span class="keyword">...</span>
                        <span class="string">'Wrong number of arguments.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">if</span> ~(isa(gridObj,<span class="string">'grid2DR'</span>)||isa(gridObj,<span class="string">'grid2D'</span>))
                MException(<span class="string">'finiteElements2D:WRONGARGS'</span>,<span class="keyword">...</span>
                        <span class="string">'The first argument must be a grid2DR object.'</span>).throwAsCaller;
            <span class="keyword">end</span>

            <span class="comment">%  index of Faces</span>
<span class="comment">%             indexOfRobinBEs = gridObj.indexOfRobinBoundaryElements;</span>

            <span class="comment">% x-y-coordinates of the three face points...</span>
            <span class="comment">% p = gridObj.p(1:2,gridObj.e(1:3,k));</span>
            p1 = gridObj.p(1:2, gridObj.e(1,gridObj.indexOfRobinBoundaryElements));
            p2 = gridObj.p(1:2, gridObj.e(2,gridObj.indexOfRobinBoundaryElements));

            <span class="comment">% get element corner coordinates</span>
            x21 = p2(1,:)-p1(1,:);
            y21 = p2(2,:)-p1(2,:);

            <span class="comment">% Compute Jacobi determinat wrt. boundary points.</span>
            J = sqrt(x21.^2+y21.^2);

            <span class="comment">% Use elementary mass matrix from objboundaryElement class to compute</span>
            <span class="comment">% the 1 dimensional integrals.</span>

            dm = length(obj.boundaryElements.M);
            df = length(obj.boundaryElements.F);

            Qe = reshape(obj.boundaryElements.M*(J.*q),1,dm*gridObj.nRobinBoundaryElements);
            ge = reshape(obj.boundaryElements.F*(J.*g),1,df*gridObj.nRobinBoundaryElements);

            <span class="comment">% rearanging like in assema...</span>
            <span class="comment">% Note that we must take case if the mesh is extended.</span>
            <span class="keyword">if</span> gridObj.isExtended
                 indexOfPoints = gridObj.e([1 2 6],gridObj.indexOfRobinBoundaryElements);
            <span class="keyword">else</span>
                indexOfPoints = gridObj.e(1:2,gridObj.indexOfRobinBoundaryElements);
            <span class="keyword">end</span>

            <span class="comment">% We use again obj.booundaryElements vlass to compute</span>
            <span class="comment">% indeces...</span>
            [indx0,indx1,indx2] = obj.boundaryElements.makeIndex(indexOfPoints,gridObj.nRobinBoundaryElements) ;

            <span class="comment">% Similar to assema: sparse-magic</span>
            Q = sparse(indx1,indx2,Qe,gridObj.nPoints,gridObj.nPoints);
            G = sparse(indx0,1,ge,gridObj.nPoints,1);
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> [Q,G,H,R] = assemb(obj,gridObj)

            <span class="comment">% Idee Daten aus gridObj.b gewinnen</span>
            <span class="comment">% dann assembDataRobin</span>
            <span class="comment">% bzw assembDataDirichlet berechnen.</span>
            H = sparse(1,gridObj.nPoints);
            R = sparse(1,1);
            h = [];
            r = [];

            Q = sparse(gridObj.nPoints,gridObj.nPoints);
            G = sparse(gridObj.nPoints,1);
            q = [];
            g = [];
            <span class="comment">% If no Dirichlet BCs, do nothing</span>


            <span class="keyword">for</span> k = gridObj.indexOfDirichletBoundarySegments
                <span class="keyword">if</span> ~isArclengthParametrized(gridObj.b(:,k))
                    bp = gridObj.getBoundaryPointsIndexPerSegment(k);
                    p = [gridObj.x(bp);gridObj.y(bp)];
                    [~,~,hval,rval] = gridObj.boundCoefficients(p,gridObj.b(:,k));
                    <span class="keyword">if</span> isscalar(hval)
                        hval = hval(ones(1,size(bp,2)));
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> isscalar(rval)
                        rval = rval(ones(1,size(bp,2)));
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    bp = gridObj.getBoundaryPointsIndexPerElement(k);
                    be = gridObj.getBoundaryElementsIndex(k);
                    [~,b,~] = unique(bp);
                    <span class="keyword">if</span> gridObj.isExtended
                         S = reshape([gridObj.e([3 4],be)
                             0.5*(gridObj.e(3,be)+gridObj.e(4,be))],1,<span class="keyword">...</span>
                            length(be)*3);
                        S = S(b);
                    <span class="keyword">else</span>
                        S = reshape(gridObj.e(3:4,be),1,<span class="keyword">...</span>
                            length(be)*2);
                        S = S(b);
                    <span class="keyword">end</span>
                    [~,~,hval,rval] = gridObj.boundCoefficients(S,gridObj.b(:,k));
                <span class="keyword">end</span>

                h = [h,hval]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                r = [r,rval]; <span class="comment">%#ok&lt;AGROW&gt;</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~(isempty(h)||isempty(r))
                [H,R] = obj.assembDataDirichlet(gridObj,h,r);
            <span class="keyword">end</span>

            <span class="keyword">for</span> k = gridObj.indexOfRobinBoundarySegments
                <span class="keyword">if</span> ~isArclengthParametrized(gridObj.b(:,k))
                    mp = gridObj.midpointsOfBoundaryElements(k);
                    [qval,gval,~,~] = gridObj.boundCoefficients(mp,gridObj.b(:,k));
                    <span class="keyword">if</span> isscalar(qval)
                        qval = qval(ones(1,size(mp,2)));
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> isscalar(gval)
                        gval = gval(ones(1,size(mp,2)));
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    be = gridObj.getBoundaryElementsIndex(k);
                    S = 0.5*(gridObj.e(3,be)+gridObj.e(4,be));
                    [qval,gval,~,~] = gridObj.boundCoefficients(S,gridObj.b(:,k));
                    <span class="keyword">if</span> isscalar(qval)
                        qval = qval(ones(1,size(S,2)));
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> isscalar(gval)
                        gval = gval(ones(1,size(S,2)));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                q = [q qval];
                g = [g gval];
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~(isempty(q)||isempty(g))
                [Q,G] = obj.assembDataRobin(gridObj,q,g);
            <span class="keyword">end</span>

            <span class="keyword">function</span> val = isArclengthParametrized(b)
                <span class="comment">% Checks if the function in b are arc-length-parametrized</span>
                <span class="comment">% or not by trial-and-error.</span>

                val = false;
                x = 0; y = 0; <span class="comment">%#ok&lt;*NASGU&gt;</span>
                <span class="comment">% We need x and y for evaluation of string expressions</span>
                <span class="comment">% like 'sin(x)+y'</span>
                <span class="keyword">if</span> b(2) == 0
                    lengthq = b(3);
                    lengthg = b(4);
                    <span class="comment">% Neumann  BC on this edge segment</span>
                    <span class="keyword">try</span> <span class="comment">% checks if g = g(x,y) or g = const</span>
                        <span class="comment">% if it works, q and g are written in terms of (x,y)</span>
                        a1 = eval(char(b(5:5+b(3)-1)));
                        a2 = eval(char(b(5+lengthq:5+lengthq+lengthg-1)));
                        <span class="keyword">if</span> ~(isnumeric(a1)&amp;&amp;isnumeric(a2))
                            throw(finiteElement.wrongClass)
                        <span class="keyword">end</span>
                    <span class="keyword">catch</span> <span class="comment">% Don#t catch it</span>
                        <span class="comment">% Tricky: If an exception was thrown, it must be</span>
                        <span class="comment">% parametrisied in arclength, i.e. g = g(s) etc.</span>
                        val = true;
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="comment">% Dirichlet  BC on this edge segment</span>
                    <span class="keyword">try</span>
                        <span class="comment">% if it works, h is written in terms of (x,y)</span>
                        lengthh = b(5);
                        lengthr = b(6);
                        a1 = eval(char(b(9:9+lengthh-1)));
                        a2 = eval(char(b(9+lengthh:9+lengthh+lengthr-1)));
                        <span class="keyword">if</span> ~(isnumeric(a1)&amp;&amp;isnumeric(a2))
                            throw(finiteElement.wrongClass)
                        <span class="keyword">end</span>
                    <span class="keyword">catch</span>  <span class="comment">% Don#t catch it</span>
                        <span class="comment">% if it not works, it must be written as g(s)</span>
                        val = true;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% finiteElements2D
% Abstract class to build Finite Elements for 2D domains.

%% Copy style
% handle

%% Inheritance
% finiteElements2D < finiteElements < handle
classdef (Abstract) finiteElements2D < finiteElements
    properties(Abstract = true,...
            Constant = true,...
            Access = protected)
        boundaryElements 
        % Defines the boundary elements for assembling the boundary
        % condtion. 
    end
    
    properties(Abstract = true, Constant = true, Access = public)
        % The order of point indices in the e field. Trivialy [1,2] for P1 
        % elements but important for extended meshes.
        boundaryIndex
    end
        
    methods(Access = public)
        function [K,M,F] = createMatrixEntries(obj,gridObj,cf,af,ff)
            % the sizes of elementary matrices, varies from element
            % type to element type...
            % The space needed by sparse methods. Note that S1 etc are
            % stored as vectors. It length is 9 in the case of linear
            % Elements on triangles but it can vary 
            sizeVector = sqrt(size(obj.S1,1));
            sizeMatrix = size(obj.S1,1);   
            
            % compute the coefficients. The result is always a k x nElelemts
            % matrix where k = 4 for c, k = 1 for a and f.
            [cval,aval,fval] = obj.aCoefficients(gridObj,cf,af,ff);
                
            % We obtain the Matrices from the exact integration multiplied
            % by the grid-dependent but for fix grid constant
            % transformations.
            [K1,K12,K2] = obj.getConstantPartOfStiffnessMatrix(gridObj);           
            % Now we have to multiply the Ks by c(1) and c(2).
            % For the mixed derivatives, this code must be EXTENDED.
            K = reshape(...
                K1*sparse(1:gridObj.nElements,1:gridObj.nElements,...
                cval(1,:))+ K2*sparse(1:gridObj.nElements,1:gridObj.nElements,...
                cval(4,:))+ K12*sparse(1:gridObj.nElements,1:gridObj.nElements,...
                cval(3,:)+cval(2,:)),...
                1,...
                gridObj.nElements*sizeMatrix);            
                    
            M = reshape(obj.M*(aval.*obj.makeJ(gridObj)),...
                1,...
                gridObj.nElements*sizeMatrix); 
            
            F = reshape(obj.F*(obj.makeJ(gridObj).*fval),1,...
                gridObj.nElements*sizeVector);
        end
        
        function val = createConvectionEntries(obj,gridObj,b)
            % the point of the triagles
            p1 = gridObj.p(:,(gridObj.t(1,:)));
            p2 = gridObj.p(:,(gridObj.t(2,:)));
            p3 = gridObj.p(:,(gridObj.t(3,:)));
            % get element corner coordinates
            x21 = p2(1,:)-p1(1,:);
            x31 = p3(1,:)-p1(1,:);
            y21 = p2(2,:)-p1(2,:);
            y31 = p3(2,:)-p1(2,:);
            bval = obj.convCoefficients(gridObj,b);
            J1 = bval(:,1)'.*y31-bval(:,2)'.*x31; 
            J2 = bval(:,2)'.*x21-bval(:,1)'.*y21;      
            % This works for P1 and P2 etc. elements, really
            val = reshape(obj.C1*J1+obj.C2*J2,1,gridObj.nElements*size(obj.C1,1));             
        end          
    end
    
    methods(Access = public,Hidden)
        function [K1,K12,K2] = getConstantPartOfStiffnessMatrix(obj,gridObj)
            % Needed by createMatrixEntries
            % helper method to compute the former abstract J 
            %                        
            p1 = gridObj.p(:,(gridObj.t(1,:)));
            p2 = gridObj.p(:,(gridObj.t(2,:)));
            p3 = gridObj.p(:,(gridObj.t(3,:))); 
            
            % get element corner coordinates
            x21 = p2(1,:)-p1(1,:);
            x31 = p3(1,:)-p1(1,:); 
            
            y21 = p2(2,:)-p1(2,:);
            y31 = p3(2,:)-p1(2,:); 
            
            % now we compute J for every element in one operation              
            J = obj.makeJ(gridObj) ;    
            % Inversion by using the famous 2x2 inversion formula, but with
            % out division by J: A few lines later we compute e.g.
            % xi_x^2*j so we can "correct" this "mistake"  here.
            xi_x  =  y31; 
            eta_x = -y21;
            xi_y = -x31;
            eta_y = x21;  
            
            K1 = obj.S1*((xi_x.^2)./J) + obj.S3*((eta_x.^2)./J)...
                +  obj.S2*((xi_x.*eta_x)./J);
            
            K2 = obj.S1*((xi_y.^2)./J) + obj.S3*((eta_y.^2)./J)...
                +  obj.S2*((xi_y.*eta_y)./J);
            % The following will work only for symmetric matrices.
            K12 = obj.S1*((xi_y.*xi_x)./J) + obj.S3*((eta_y.*eta_x)./J)...
                +  obj.S2*((xi_y.*eta_x+ xi_x.*eta_y )./J/2);   
        end
    end
    
    methods(Static,Access=protected)
        function [cval,aval,fval] =  aCoefficients(gridObj,cc,aa,ff)
            [cval,aval,fval] = gridObj.aCoefficientsMpt(cc,aa,ff);
        end       
        
        function bval = convCoefficients(gridObj,b)
            bval = gridObj.convCoefficientsMpt(b);
        end
     
        function J = makeJ(gridObj)   
            % compute Jacobi determinat
            if ~(isa(gridObj,'grid2D')||isa(gridObj,'grid2DR'))
                gridObj.wrongClass.throwAsCaller;
            end
            %heim_neu
            if gridObj.isExtended
                p = gridObj.p(:,1:gridObj.NrPO);
            else
                p = gridObj.p;
            end
            % end heim_neu
            t = gridObj.t;
            p1 = p(:,(t(1,:)));
            p2 = p(:,(t(2,:)));
            p3 = p(:,(t(3,:)));
            x21 = p2(1,:)-p1(1,:);
            x31 = p3(1,:)-p1(1,:);
            y21 = p2(2,:)-p1(2,:);
            y31 = p3(2,:)-p1(2,:);            
            J = x21.*y31-x31.*y21;               
        end
        
        
        %Implement abstract inheritance from finiteElements class
        function ddncu = fluxThroughEdges(obj,u,c)
            % fluxThroughEdges Fluxes of -div(c grad(u)) 
            % through edges of triangles.
            % ddncu = obj.fluxThroughEdges(grid,u,c)

            
            % Arguments check:
            switch length(c)
                case {1, obj.nElements}
                    % c fits!
                case obj.nPoints
                    c = obj.point2Center(c);
                otherwise
                    % c is miss-dimensioned
                    obj.wrongFormat.throwAsCaller;  
            end
            if length(u)~=obj.nPoints
                obj.wrongFormat.throwAsCaller; 
            end
                
            
            [sideLength, elementArea] = obj.sideLengthAndArea;
            

            dx = zeros(3,obj.nElements); dy = zeros(3,obj.nElements);
            for k = 1:3
                k1 = rem(k ,3)+1;
                k2 = rem(k1,3)+1;
                dx(k,:) = obj.p(1,obj.t(k1,:)) - obj.p(1,obj.t(k2,:));
                dy(k,:) = obj.p(2,obj.t(k1,:)) - obj.p(2,obj.t(k2,:));
            end
            % gradients of basis functions
            g1x=0.5*dy(1,:)./elementArea;
            g2x=0.5*dy(2,:)./elementArea;
            g3x=0.5*dy(3,:)./elementArea;
            g1y=-0.5*dx(1,:)./elementArea;
            g2y=-0.5*dx(2,:)./elementArea;
            g3y=-0.5*dx(3,:)./elementArea;

            % preparations  

            % select points from triangle
            it1=obj.t(1,:);
            it2=obj.t(2,:);
            it3=obj.t(3,:);

            % Compute gradient numerically
            % grad_x
            gradx = u(it1,:).'.*(g1x)+u(it2,:).'.*(g2x)+ ...
                  u(it3,:).'.*(g3x);

            % grad_y  
            grady = u(it1,:).'.*(g1y)+u(it2,:).'.*(g2y)+ ...
                  u(it3,:).'.*(g3y);

            % Compute c * grad u
            nrc=size(c,1);
            cgradx=zeros(1,obj.nElements);
            cgrady=zeros(1,obj.nElements);
            if nrc==1 
                cgradx(1,:)=c.*gradx(1,:);
                cgrady(1,:)=c.*grady(1,:);                
            elseif nrc==2 
                cgradx(1,:)=c(1,:).*gradx(1,:);
                cgrady(1,:)=c(2,:).*grady(1,:); 
            elseif nrc==3 
                cgradx(1,:)=c(1,:).*gradx(1,:)+c(2,:).*grady(1,:);
                cgrady(1,:)=c(2,:).*gradx(1,:)+c(3,:).*grady(1,:);               
            elseif nrc==4 
                cgradx(1,:)=c(1,:).*gradx(1,:)+c(3,:).*grady(1,:);
                cgrady(1,:)=c(2,:).*gradx(1,:)+c(4,:).*grady(1,:);
            else
              MException(obj.wrongInputFormatID,...
                    [obj.wrongInputFormatStr,'Wrong format of c.']).throwAsCaller
            end

            % nhat'*c grad u
            % edge unit normals : outwards positive if the nodes are in
            % anti-clockwise order
            % nhatx =   dy./s;
            % nhaty = - dx./s;
            ddncu = zeros(3,obj.nElements);             
            for k = 1:3
                ddncu(k,:) = (dy(k,:).*cgradx(1,:) - dx(k,:).*cgrady(1,:))./sideLength(k,:);
            end
        end

        function jumps = fluxJumps(obj,fluxThroughElementEdges,m)
            jumps = zeros(1,obj.nElements);
            [sideLength, ~] = obj.sideLengthAndArea;

            % REPLACE_WITH_DASH_DASH- this is dimension depending REPLACE_WITH_DASH_DASH here 2D triangle
            interiorEdges=sparse(obj.t([2 3 1],:),obj.t([3 1 2],:),1,obj.nPoints,obj.nPoints);
            % intj+intj.' is 2 if interior edge and 1 if exterior edge

            % REPLACE_WITH_DASH_DASH- Interior only
            interiorEdges=round((interiorEdges+interiorEdges.')/3);



            jmps = sparse(obj.t([2 3 1],:),obj.t([3 1 2],:),...
                fluxThroughElementEdges([1 2 3],:),obj.nPoints,obj.nPoints);
            

            jmps = interiorEdges.*abs(jmps + jmps.');
            for l = 1:obj.nElements
                jumps(l) = (sideLength(3,l)^m*abs(jmps(obj.t(1,l),obj.t(2,l))))^2+...
                       (sideLength(1,l)^m*abs(jmps(obj.t(2,l),obj.t(3,l))))^2+...
                       (sideLength(2,l)^m*abs(jmps(obj.t(3,l),obj.t(1,l))))^2;
            end
        end    
    end
    
    methods(Access=public,...
            Static = true)
        

        function [H,R] = assembDataDirichlet(gridObj,arg1,arg2)
            
            switch nargin
                case 1 % No data given: Assume homogenious Dirichlet Problem 
                    arg1 = 1;
                    arg2 = 0;
                case 2 % only R given: Implement h = r
                    arg2 = arg1;
                    arg1 = 1;
                case 3
                    % Nothig to do.
            end
            
            if ~(isa(gridObj,'grid2DR')||isa(gridObj,'grid2D'))
                MException('BILINEAR3D:WRONGARGS',...
                        'The first argument must be a grid2DR object.').throwAsCaller;
            end
            
            % The case of intersecting Dirichlet boundary segments.
            if gridObj.nDirichletBoundaryPoints~=...
                length(gridObj.indexOfDirichletBoundaryPoints)
                fprintf(['\nWarning: Two or more Dirichlet boundary segments have common points.\n',...
                    'In this case, the boundary value function may be not continuous.\n',...
                    'The value that appears first in the arguments \n',...
                    'will be taken, the second will be ignored.\n\n']);
                
                [~,s,~] = unique(gridObj.indexOfDirichletBoundaryPoints,'stable');
                              
                if isscalar(arg1)
                    h = arg1(ones(1,gridObj.nDirichletBoundaryPoints));
                else
                    h = arg1(s);
                end
                
                if isscalar(arg2)
                    R = arg2(ones(gridObj.nDirichletBoundaryPoints,1));
                else
                    R = arg2(s);
                end
                
                H = sparse(1:gridObj.nDirichletBoundaryPoints,...
                        gridObj.indexOfDirichletBoundaryPoints(s),...
                        h,...
                        gridObj.nDirichletBoundaryPoints,...
                        gridObj.nPoints);  
                
                
                R = R(:);
            else
                if isscalar(arg1)
                    h = arg1(ones(1,gridObj.nDirichletBoundaryPoints));
                else
                    h = arg1;
                end
                
                if isscalar(arg2)
                    R = arg2(ones(gridObj.nDirichletBoundaryPoints,1));
                else
                    R = arg2(:);
                end
                H = sparse(1:gridObj.nDirichletBoundaryPoints,...
                        gridObj.indexOfDirichletBoundaryPoints,...
                        h,...
                        gridObj.nDirichletBoundaryPoints,...
                        gridObj.nPoints);  
            end
        end
    end
    
    methods(Access=public)
        function [Q,G] = assembDataRobin(obj,gridObj,arg1,arg2)
            %% assembDataRobin
            %  IN:self, grid2DR,double[,double] OUT:double,double
            %
            % Assembles matrix Q and G from data vectors.
            % Arguments are the grid, the data g (Neumann BC) or q and g.
            % 
            % The data vectors must contain the value of q(x) and g(x)
            % respectivelly in the barycenters of the boundary elements,
            % triangle or sqares, respectivelly. 
            %
            % The order of the data must be the order of elements in obj.e.
            % of the Robin and/or Neumann baundary conditions.
            
            % prepare and test data.
            
            % Since the boundary elements in the boundary  segments are not
            % increasing we resort the data.
            switch nargin
                case 3 % Only g given: Neumann boudarys 
                    g = arg1;    
                    if isscalar(g)
                        g = g(ones(1,gridObj.nRobinBoundaryElements));
                    elseif isvector(g)&&length(g)==gridObj.nRobinBoundaryElements  
                            %  okay
                    else
                        gridObj.wrongFormat.throwAsCaller;
                    end
                    q = zeros(1,gridObj.nRobinBoundaryElements);
                case 4
                    g = arg2;
                    if isscalar(g)
                        g = g(ones(1,gridObj.nRobinBoundaryElements));
                    elseif isvector(g)&&length(g)==gridObj.nRobinBoundaryElements  
                        %  okay 
                    else
                        gridObj.wrongFormat.throwAsCaller;
                    end                     
                    q = arg1;
                    if isscalar(q)
                        q = q(ones(1,gridObj.nRobinBoundaryElements));
                    elseif isvector(q)&&length(q)==gridObj.nRobinBoundaryElements  
                         % okay
                    else
                        gridObj.wrongFormat.throwAsCaller;
                    end
                                      
                otherwise %
                    MException('BILINEAR3D:WRONGNUMBERARGS',...
                        'Wrong number of arguments.').throwAsCaller;
            end
            if ~(isa(gridObj,'grid2DR')||isa(gridObj,'grid2D'))
                MException('finiteElements2D:WRONGARGS',...
                        'The first argument must be a grid2DR object.').throwAsCaller;
            end
                        
            %  index of Faces 
%             indexOfRobinBEs = gridObj.indexOfRobinBoundaryElements;
            
            % x-y-coordinates of the three face points... 
            % p = gridObj.p(1:2,gridObj.e(1:3,k));
            p1 = gridObj.p(1:2, gridObj.e(1,gridObj.indexOfRobinBoundaryElements));
            p2 = gridObj.p(1:2, gridObj.e(2,gridObj.indexOfRobinBoundaryElements));            

            % get element corner coordinates
            x21 = p2(1,:)-p1(1,:);            
            y21 = p2(2,:)-p1(2,:);                 
            
            % Compute Jacobi determinat wrt. boundary points. 
            J = sqrt(x21.^2+y21.^2);          
            
            % Use elementary mass matrix from objboundaryElement class to compute
            % the 1 dimensional integrals. 
            
            dm = length(obj.boundaryElements.M);
            df = length(obj.boundaryElements.F);
            
            Qe = reshape(obj.boundaryElements.M*(J.*q),1,dm*gridObj.nRobinBoundaryElements);
            ge = reshape(obj.boundaryElements.F*(J.*g),1,df*gridObj.nRobinBoundaryElements); 
            
            % rearanging like in assema...
            % Note that we must take case if the mesh is extended.
            if gridObj.isExtended
                 indexOfPoints = gridObj.e([1 2 6],gridObj.indexOfRobinBoundaryElements);
            else
                indexOfPoints = gridObj.e(1:2,gridObj.indexOfRobinBoundaryElements);
            end
 
            % We use again obj.booundaryElements vlass to compute
            % indeces...
            [indx0,indx1,indx2] = obj.boundaryElements.makeIndex(indexOfPoints,gridObj.nRobinBoundaryElements) ;       
            
            % Similar to assema: sparse-magic
            Q = sparse(indx1,indx2,Qe,gridObj.nPoints,gridObj.nPoints); 
            G = sparse(indx0,1,ge,gridObj.nPoints,1);              
        end
        
        function [Q,G,H,R] = assemb(obj,gridObj)
            
            % Idee Daten aus gridObj.b gewinnen
            % dann assembDataRobin
            % bzw assembDataDirichlet berechnen.
            H = sparse(1,gridObj.nPoints);
            R = sparse(1,1);
            h = [];
            r = [];    
            
            Q = sparse(gridObj.nPoints,gridObj.nPoints);
            G = sparse(gridObj.nPoints,1);
            q = [];
            g = [];
            % If no Dirichlet BCs, do nothing
            
            
            for k = gridObj.indexOfDirichletBoundarySegments
                if ~isArclengthParametrized(gridObj.b(:,k))
                    bp = gridObj.getBoundaryPointsIndexPerSegment(k);
                    p = [gridObj.x(bp);gridObj.y(bp)];
                    [~,~,hval,rval] = gridObj.boundCoefficients(p,gridObj.b(:,k));  
                    if isscalar(hval)
                        hval = hval(ones(1,size(bp,2)));
                    end
                    if isscalar(rval)
                        rval = rval(ones(1,size(bp,2)));
                    end
                else
                    bp = gridObj.getBoundaryPointsIndexPerElement(k);
                    be = gridObj.getBoundaryElementsIndex(k);
                    [~,b,~] = unique(bp);                    
                    if gridObj.isExtended
                         S = reshape([gridObj.e([3 4],be)
                             0.5*(gridObj.e(3,be)+gridObj.e(4,be))],1,...
                            length(be)*3);                    
                        S = S(b);
                    else
                        S = reshape(gridObj.e(3:4,be),1,...
                            length(be)*2);                    
                        S = S(b);
                    end
                    [~,~,hval,rval] = gridObj.boundCoefficients(S,gridObj.b(:,k));                      
                end
                    
                h = [h,hval]; %#ok<AGROW>
                r = [r,rval]; %#ok<AGROW>
            end
            
            if ~(isempty(h)||isempty(r))
                [H,R] = obj.assembDataDirichlet(gridObj,h,r);
            end
                        
            for k = gridObj.indexOfRobinBoundarySegments 
                if ~isArclengthParametrized(gridObj.b(:,k))
                    mp = gridObj.midpointsOfBoundaryElements(k);                    
                    [qval,gval,~,~] = gridObj.boundCoefficients(mp,gridObj.b(:,k));
                    if isscalar(qval)
                        qval = qval(ones(1,size(mp,2)));
                    end
                    if isscalar(gval)
                        gval = gval(ones(1,size(mp,2)));
                    end
                else                    
                    be = gridObj.getBoundaryElementsIndex(k);
                    S = 0.5*(gridObj.e(3,be)+gridObj.e(4,be));
                    [qval,gval,~,~] = gridObj.boundCoefficients(S,gridObj.b(:,k));
                    if isscalar(qval)
                        qval = qval(ones(1,size(S,2)));
                    end
                    if isscalar(gval)
                        gval = gval(ones(1,size(S,2)));
                    end
                end 
                q = [q qval];
                g = [g gval]; 
            end
            
            if ~(isempty(q)||isempty(g))
                [Q,G] = obj.assembDataRobin(gridObj,q,g);
            end
            
            function val = isArclengthParametrized(b)
                % Checks if the function in b are arc-length-parametrized  
                % or not by trial-and-error.
                 
                val = false;  
                x = 0; y = 0; %#ok<*NASGU> 
                % We need x and y for evaluation of string expressions  
                % like 'sin(x)+y'
                if b(2) == 0
                    lengthq = b(3);
                    lengthg = b(4);
                    % Neumann  BC on this edge segment       
                    try % checks if g = g(x,y) or g = const                 
                        % if it works, q and g are written in terms of (x,y)
                        a1 = eval(char(b(5:5+b(3)-1)));
                        a2 = eval(char(b(5+lengthq:5+lengthq+lengthg-1)));
                        if ~(isnumeric(a1)&&isnumeric(a2))
                            throw(finiteElement.wrongClass)
                        end
                    catch % Don#t catch it
                        % Tricky: If an exception was thrown, it must be
                        % parametrisied in arclength, i.e. g = g(s) etc.
                        val = true;                         
                    end
                else
                    % Dirichlet  BC on this edge segment
                    try
                        % if it works, h is written in terms of (x,y)
                        lengthh = b(5);
                        lengthr = b(6);
                        a1 = eval(char(b(9:9+lengthh-1)));
                        a2 = eval(char(b(9+lengthh:9+lengthh+lengthr-1)));
                        if ~(isnumeric(a1)&&isnumeric(a2))
                            throw(finiteElement.wrongClass)
                        end
                    catch  % Don#t catch it 
                        % if it not works, it must be written as g(s)
                        val = true; 
                    end
                end
            end            
        end 
    end   
end

##### SOURCE END #####
--></body></html>