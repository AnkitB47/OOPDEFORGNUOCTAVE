
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>gridd</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-03-04"><meta name="DC.source" content="gridd.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>gridd</h1><!--introduction--><p>Abstract  basis class for all grid objects. Defines properties p,e,t for storing points, edges/faces, and triangles/tetraeder/prisms.</p><p>The property b stores the boundary condition matrix in pdetool style.</p><p>Note that you cannot create objects from abstract classes. It is used only as a parent class for gridXD classes  and for deriving further user classes.</p><p>gridd provides  methods that be independent from the specific type of grid or space dimension.</p><p>Copy style: handle.</p><pre class="codeoutput error">Abstract classes cannot be instantiated.  Class 'gridd' defines abstract methods and/or properties.
</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Inheritance</a></li><li><a href="#4">Properties  with SetAccess = protected</a></li><li><a href="#5">Abstract properties.</a></li><li><a href="#7">Dependent properties with GetAccess = public and SetAccess = private</a></li><li><a href="#8">Constant properties</a></li><li><a href="#9">Public methods</a></li><li><a href="#10">gridd</a></li><li><a href="#11">copy</a></li><li><a href="#13">disp</a></li><li><a href="#15">makeBoundaryMatrix</a></li><li><a href="#18">dirichletBC</a></li><li><a href="#21">neumannBC</a></li><li><a href="#25">robinBC</a></li><li><a href="#28">point2Center</a></li><li><a href="#30">center2Point</a></li><li><a href="#32">nearestPointInGrid</a></li><li><a href="#34">midpts</a></li><li><a href="#36">point2CenterMatrix</a></li><li><a href="#38">center2PointMatrix</a></li><li><a href="#40">setBoundarySegemntNumber</a></li><li><a href="#42">setSubdomainNumber</a></li><li><a href="#45">chi</a></li><li><a href="#47">refineUniformly</a></li><li><a href="#50">rotateMesh</a></li><li><a href="#52">moveMesh</a></li><li><a href="#54">scaleMesh</a></li><li><a href="#56">interpolate</a></li><li><a href="#58">getBoundaryPoints</a></li><li><a href="#60">getBoundaryElementsIndex</a></li><li><a href="#62">point2CenterB</a></li><li><a href="#64">midpointsOfBoundaryElements</a></li><li><a href="#66">getBoundaryPointsIndex</a></li><li><a href="#68">getBoundaryPointsIndexPerElement</a></li><li><a href="#70">getBoundaryPointsIndexPerSegment</a></li><li><a href="#72">getInnerPointsIndex</a></li></ul></div><pre class="codeinput"><span class="comment">% Important %% tag. Don't remove it!</span>

<span class="comment">% Note</span>
<span class="comment">% Since we want ot have a hard-copy method, all properties will be protected.</span>
<span class="comment">% Otherwise, we cannot copy them in derived classes.</span>
</pre><h2 id="2">Inheritance</h2><p>gridd &lt; handle</p><pre class="codeinput"><span class="keyword">classdef</span> (Abstract) gridd &lt; handle
</pre><pre class="codeinput">    <span class="comment">% Changes:</span>
    <span class="comment">% 8/9/2016</span>
    <span class="comment">% Change some methods to dependent props. nElements, nPoints, etc.</span>
    <span class="comment">% 5/5/2015</span>
    <span class="comment">% Add new abstract method sideLengthAndArea that computes the</span>
    <span class="comment">% sidelengths and areas of elements. Implement it in gridXd classes!</span>
    <span class="comment">%</span>
    <span class="comment">% 10/29/2013</span>
    <span class="comment">%   "geometrie" property g removed (becuase this version is pdetool free).</span>
    <span class="comment">%   nBoundarySegments is now the maximum of numbered boundary</span>
    <span class="comment">%   segments, not the number of defined boundaries in obj.b</span>
    <span class="comment">%   makeBoundaryMatrix can now be called with only one argument to give</span>
    <span class="comment">%   one boundary condition to ALL boundary segments.</span>
    <span class="comment">% 2014/08/13</span>
    <span class="comment">% Code change in nBoundarySegmenst: Now it gives back the number of</span>
    <span class="comment">% different names</span>
    <span class="comment">% Now a one parameter call of dirichletBC is possible, e.g.</span>
    <span class="comment">% dirichletBC(2) is BC y = 3;</span>
    <span class="comment">%</span>
    <span class="comment">% (c) 2013-2016 by Uwe Pr&uuml;fert</span>
</pre><h2 id="4">Properties  with SetAccess = protected</h2><div><ul><li>p (double) Coordinates of grid points</li><li>e (double) Indices of edge points</li><li>t (double) Indices of element points</li><li>isExtended (logical, <b>false</b>)</li><li>b (double) Boundary condition matrix in pdetool-style where char(b) gives the human readable definition of the boundary condition. Will be created by class methods and cannot be edited.</li></ul></div><p>For 1D and 3D grids, "edge" stands for all shapes ob boundary elements and "element" stands for all shapes of elements.</p><pre class="codeinput">    properties(GetAccess = public,<span class="keyword">...</span>
               SetAccess = protected)
        <span class="comment">%</span>
        <span class="comment">% p e t = points, edges triangle, as in PDE tool defined.</span>
        <span class="comment">%</span>

        p <span class="string">double</span>            <span class="comment">% points</span>
        e <span class="string">double</span>            <span class="comment">% edges</span>
        t <span class="string">double</span>            <span class="comment">% triangles</span>
        b                   <span class="comment">% boundary condition cell or double</span>
    <span class="keyword">end</span>

    properties(SetAccess = protected,<span class="keyword">...</span>
               GetAccess = public,<span class="keyword">...</span>
                  Hidden = true)
              isExtended <span class="string">logical</span> <span class="string">=</span> <span class="string">false</span>
                            <span class="comment">% if expanded then e.g.</span>
                            <span class="comment">% additional points added to p</span>
    <span class="keyword">end</span>
</pre><h2 id="5">Abstract properties.</h2><p>Redefine it in derived classes!</p><div><ul><li>nPointsInElements (double) number of points in elements.</li></ul></div><p>It may 2 for 1D elements, 3 or 4 for triangles or squares, or 6 for extended triangles, etc.</p><pre class="codeinput">    properties(GetAccess = public,<span class="keyword">...</span>
               SetAccess = protected,<span class="keyword">...</span>
                Abstract = true)

        nPointsInElements <span class="string">double</span>
                            <span class="comment">% Number of points in element,...</span>
                            <span class="comment">% two in 2D, three or four in 2D,...</span>
                            <span class="comment">% four or six in 3D</span>
    <span class="keyword">end</span>
</pre><div><ul><li>spaceDimension (double) Dimension of space, 1,2, or 3</li></ul></div><pre class="codeinput">    properties(GetAccess = public,<span class="keyword">...</span>
                Constant = true,<span class="keyword">...</span>
                Abstract = true)

        spaceDimension <span class="string">double</span>   <span class="comment">% Dimension of space, N = {1,2,3}.</span>
    <span class="keyword">end</span>
</pre><h2 id="7">Dependent properties with GetAccess = public and SetAccess = private</h2><div><ul><li>x (double) All values of X-coordinate</li><li>y (double) All values of Y-coordinate (if applicable)</li><li>z (double) All values of Z-coordinate (if applicable)</li></ul></div><div><ul><li>nElements (double) Number of elements in grid</li><li>nPoints (double) Number of points in grid</li><li>nEdges (double) Number of edge-elements in grid</li></ul></div><div><ul><li>nBoundarySegments (double) Number of of boundary segments in grid</li><li>nBoundaryPoints (double) Number of points on the boundary of grid</li></ul></div><div><ul><li>nDirichletPoints (double) Number of Dirichlet boundary points</li><li>nDirichletBoundarySegments (double) Number of Dirichlet boundary                                       Segments</li><li>nRobinBoundaryElements (double) Number of Robin boundary elements</li><li>nRobinBoundarySegments (double) Number of Robin boundary segments</li></ul></div><div><ul><li>indexOfDirichletBoundarySegments (double) Vector with index of Dirichlet                                   boundary segments</li><li>indexOfDirichletBoundaryPoints (double) Vector with index of Dirichlet                                   boundary points</li></ul></div><div><ul><li>indexOfRobinBoundarySegments (double) Vector with index of Robin boundary                                   segments</li><li>indexOfRobinBoundaryElements (double)  Vector with index of Robin                                   boundary elements. In order of                                   boundary segments, i.e. elements of                                   segment 1, ... elements of segment N.</li></ul></div><p>Note that such properties need a get method.</p><pre class="codeinput">    properties(GetAccess = public,<span class="keyword">...</span>
               SetAccess = private,<span class="keyword">...</span>
               Dependent = true)

        x                   <span class="comment">% x-coordinate of grid nodes</span>
        y                   <span class="comment">% y-coordinate of grid nodes</span>
        z                   <span class="comment">% z-coordinate of grid nodes</span>

        nElements           <span class="comment">% number of elements in grid</span>
        nPoints             <span class="comment">% number of points/nodes in grid</span>
        nEdges              <span class="comment">% number of edges/faces (in 1D always two)</span>

        nBoundarySegments   <span class="comment">% number of boundary segments.</span>
        nBoundaryPoints     <span class="comment">% number of boundary points/nodes</span>
        <span class="comment">% New in R2018</span>
        nSubDomains         <span class="comment">% number of subdomains</span>

        nDirichletBoundaryPoints    <span class="comment">% number of dirichlet boundary points/nodes</span>
        nDirichletBoundarySegments <span class="comment">% number of Dirichlet boundary Segments</span>

        nRobinBoundaryElements  <span class="comment">% number of Robin boundary elements</span>
        nRobinBoundarySegments  <span class="comment">% number of Robin boundary segments</span>

        indexOfDirichletBoundarySegments <span class="comment">% index vector of Dirichlet segments</span>
        indexOfDirichletBoundaryPoints   <span class="comment">% index vector of Dirichlet boundary points</span>
        indexOfRobinBoundarySegments     <span class="comment">% index vector of Robin boundary segments</span>
        indexOfRobinBoundaryElements     <span class="comment">% index vector of Robin boundary elements</span>

    <span class="keyword">end</span>

    properties(   Access = public,<span class="keyword">...</span>
                  Hidden = true)
        NrPO@double         <span class="comment">% Number of points before the mesh extending</span>
                            <span class="comment">% M Heim.</span>
    <span class="keyword">end</span>

    properties(SetAccess = protected,<span class="keyword">...</span>
                  Hidden = true)
        ngpts@double        <span class="comment">% number of grid points w/o extended points</span>

    <span class="keyword">end</span>
</pre><h2 id="8">Constant properties</h2><p>Some execption defined as constants. MException objects. Call them with e.g.</p><pre class="language-matlab">obj.wrongNumerInputs.throwAsCaller
</pre><div><ul><li>wrongNumberInputs (MException)</li><li>wrongFormat (MException)</li><li>wrongClass (MException)</li><li>wrongNumberPoints (MException)</li><li>privateProp (MException)</li><li>noIndexing (MException)</li><li>wrongNumberOfBoundaryConditions (MException)</li></ul></div><pre class="codeinput">    properties(GetAccess = public,<span class="keyword">...</span>
                Constant = true)

        wrongNumberInputs = MException(<span class="string">'GRIDD:WRONGNUMBERINPUTS'</span>,<span class="keyword">...</span>
            <span class="string">'The number of arguments is wrong, check it.'</span>);
        wrongFormat = MException(<span class="string">'GRIDD:WRONGFORMAT'</span>,<span class="keyword">...</span>
            <span class="string">'Input has the wrong format, check it.'</span>);
        wrongClass = MException(<span class="string">'GRIDD:WRONGCLASS'</span>,<span class="keyword">...</span>
            <span class="string">'Wrong argument class, check it.'</span>);
        wrongNumberPoints = MException(<span class="string">'GRIDD:WRONGPOINTS'</span>,<span class="keyword">...</span>
            <span class="string">'Wrong number of points, check it!'</span>);
        privateProp = MException(<span class="string">'GRIDD:PRIVATE'</span>,<span class="keyword">...</span>
            <span class="string">'The property is declared as private or do not exist.'</span>);
        noIndexing = MException(<span class="string">'GRIDD:INDEX'</span>,<span class="keyword">...</span>
            <span class="string">'No arrays of gridd allowed.'</span>);
        wrongNumberOfBoundaryConditions = MException(<span class="keyword">...</span>
            <span class="string">'GRIDD:WRONGBOUNDARYCOND'</span>,<span class="keyword">...</span>
            <span class="string">'The number of boudary conditions in matrix b and in geometry don''t match.'</span>)
    <span class="keyword">end</span>

    methods
        <span class="comment">% For dependent properties.</span>

        <span class="comment">% The get methods checks if the property should "exist" dependently</span>
        <span class="comment">% from the dimension of the space e.i. of the grid.</span>
        <span class="keyword">function</span> val = get.x(obj)
            <span class="keyword">if</span> isempty(obj.p)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = obj.p(1,:);
        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.y(obj)
            <span class="keyword">if</span> isempty(obj.p)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">elseif</span> size(obj.p,1)&lt;2
                MException(<span class="string">'GRIDD:NOSUCHPROP'</span>,<span class="keyword">...</span>
                    [num2str(obj.spaceDimension),<span class="keyword">...</span>
                    <span class="string">'D meshes have no property y.'</span>]).throwAsCaller;
            <span class="keyword">else</span>
                val = obj.p(2,:);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.z(obj)
            <span class="keyword">if</span> isempty(obj.p)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">elseif</span> size(obj.p,1)&lt;3
                MException(<span class="string">'GRIDD:NOSUCHPROP'</span>,<span class="keyword">...</span>
                    [num2str(obj.spaceDimension),<span class="keyword">...</span>
                    <span class="string">'D meshes have no property z.'</span>]).throwAsCaller;
            <span class="keyword">else</span>
                val = obj.p(3,:);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">%-----------------------------</span>

        <span class="keyword">function</span> val = get.nElements(obj)
            <span class="keyword">if</span> isempty(obj.t)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = size(obj.t,2);
        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.nPoints(obj)
            <span class="keyword">if</span> isempty(obj.p)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = size(obj.p,2);
        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.nEdges(obj)
            <span class="keyword">if</span> isempty(obj.e)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = size(obj.e,2);
        <span class="keyword">end</span>

        <span class="comment">%------------------------------</span>

        <span class="keyword">function</span> val = get.nBoundarySegments(obj)
            <span class="keyword">if</span> isempty(obj.e)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = length(unique(obj.e(5,:)));
        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.nSubDomains(obj)
            val = length(unique(obj.t(end,:)));
        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.nBoundaryPoints(obj)
            <span class="keyword">if</span> isempty(obj.e)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">if</span> isa(obj,<span class="string">'grid3Dpr'</span>)
                N = 4;
            <span class="keyword">else</span>
                N = size(obj.p,1);
            <span class="keyword">end</span>
            val = length(find(unique(obj.e(1:N,:))&gt;0));
        <span class="keyword">end</span>

        <span class="comment">%------------------------------</span>

        <span class="keyword">function</span> val = get.nDirichletBoundaryPoints(obj)
            <span class="keyword">if</span> isempty(obj.e)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(obj.b)
                MException(<span class="string">'GRIDD:NOBOUNDARYCONDITION'</span>,<span class="keyword">...</span>
                    <span class="string">'No boundary conditions defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = length(unique(obj.indexOfDirichletBoundaryPoints));

        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.nDirichletBoundarySegments(obj)
            <span class="keyword">if</span> isempty(obj.b)
                MException(<span class="string">'GRIDD:NOBOUNDARYCONDITION'</span>,<span class="keyword">...</span>
                    <span class="string">'No boundary conditions defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = sum(obj.b(2,:)==1);

        <span class="keyword">end</span>

        <span class="comment">%-------------------------------</span>

        <span class="keyword">function</span> val = get.nRobinBoundaryElements(obj)
            <span class="keyword">if</span> isempty(obj.e)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(obj.b)
                MException(<span class="string">'GRIDD:NOBOUNDARYCONDITION'</span>,<span class="keyword">...</span>
                    <span class="string">'No boundary conditions defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = 0;
            <span class="keyword">for</span> k = obj.indexOfRobinBoundarySegments
                val = val + sum(obj.e(5,:)==k);
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.nRobinBoundarySegments(obj)
            <span class="keyword">if</span> isempty(obj.b)
                MException(<span class="string">'GRIDD:NOBOUNDARYCONDITION'</span>,<span class="keyword">...</span>
                    <span class="string">'No boundary conditions defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = sum(obj.b(2,:)==0);

        <span class="keyword">end</span>

        <span class="comment">%------------------------------</span>

        <span class="keyword">function</span> val = get.indexOfDirichletBoundarySegments(obj)
            <span class="keyword">if</span> isempty(obj.b)
                MException(<span class="string">'GRIDD:NOBOUNDARYCONDITION'</span>,<span class="keyword">...</span>
                    <span class="string">'No boundary conditions defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = find(obj.b(2,:)==1);

        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.indexOfDirichletBoundaryPoints(obj)

            <span class="comment">%Important note:  If Dirichlet boundary segments are</span>
            <span class="comment">%neighbored, then common point appears in this list twice.</span>


            <span class="keyword">if</span> isempty(obj.e)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(obj.b)
                MException(<span class="string">'GRIDD:NOBOUNDARYCONDITION'</span>,<span class="keyword">...</span>
                    <span class="string">'No boundary conditions defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = [];
            <span class="keyword">switch</span> obj.spaceDimension
                <span class="keyword">case</span> 1
                    val = obj.e(1:2,1);
                <span class="keyword">case</span> 2
                    <span class="keyword">for</span> k = obj.indexOfDirichletBoundarySegments
                        <span class="keyword">if</span> obj.isExtended
                            indx = unique(obj.e([1 2 6],obj.e(5,:)==k));
                        <span class="keyword">else</span>
                            indx = unique(obj.e(1:2,obj.e(5,:)==k));
                        <span class="keyword">end</span>
                        val = [val indx(:)']; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    <span class="keyword">end</span>
                <span class="keyword">case</span> 3
                    <span class="keyword">for</span> k = obj.indexOfDirichletBoundarySegments
                        val =  [val unique(obj.e(1:4,obj.e(5,:)==k))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    <span class="keyword">end</span>

                    <span class="keyword">if</span> val(1) == 0
                        val(1) = [];
                    <span class="keyword">end</span>
            <span class="keyword">end</span>

            val = val(:)'; <span class="comment">% row vector</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.indexOfRobinBoundarySegments(obj)
            <span class="keyword">if</span> isempty(obj.b)
                MException(<span class="string">'GRIDD:NOBOUNDARYCONDITION'</span>,<span class="keyword">...</span>
                    <span class="string">'No boundary conditions defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = find(obj.b(2,:)==0);

        <span class="keyword">end</span>

        <span class="keyword">function</span> val = get.indexOfRobinBoundaryElements(obj)
            <span class="keyword">if</span> isempty(obj.e)
                MException(<span class="string">'GRIDD:NOGRID'</span>,<span class="keyword">...</span>
                    <span class="string">'No grid defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(obj.b)
                MException(<span class="string">'GRIDD:NOBOUNDARYCONDITION'</span>,<span class="keyword">...</span>
                    <span class="string">'No boundary conditions defined.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = [];
            <span class="keyword">for</span> k = obj.indexOfRobinBoundarySegments
                val = [val find(obj.e(5,:)==k)]; <span class="comment">%#ok&lt;AGROW&gt;</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><h2 id="9">Public methods</h2><pre class="codeinput">    methods(Access = public)
</pre><h2 id="10">gridd</h2><p>IN:nothing OUT:gridd</p><p>Default constructor method without arguments.</p><p>Note that gridd is abstract and makes only sense to derive subclasses. Derived subclasses are</p><div><ul><li>grid1D      Interval "grids". Only userclass is Interval</li><li>grid2D      2D driangle grids. Userclasses are UnitSquare etc.</li><li>grid3D      3D tetrahedral grids. Userclasses are Ball etc.</li><li>grid3Dpr    3D prism grids. Userclasses are Part3D or               Coil3D</li></ul></div><p>Derive further classes if usefull.</p><pre class="codeinput">        <span class="keyword">function</span> obj2 = copy(obj1)
</pre><h2 id="11">copy</h2><p>IN:self OUT:gridd</p><p>Hardcopy method.</p><p>Note it copies only properties p, e, t, and b.</p><p>Call:</p><pre class="language-matlab">obj2 = obj1.copy
</pre><p>Override it in derived classes if there are additional (non dependent) properties.</p><pre class="codeinput">            eval([<span class="string">'obj2 = '</span>,class(obj1),<span class="string">';'</span>]);
            <span class="keyword">if</span> ~isempty(obj1)
                obj2.p = obj1.p;
                obj2.e = obj1.e;
                obj2.t = obj1.t;
                obj2.b = obj1.b;
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> disp(obj)
</pre><h2 id="13">disp</h2><p>IN:self OOU:nothing</p><p>disp methods. Overrides default disp inherited from handle.</p><pre class="language-matlab">obj.disp
</pre><p>Displays the class and provides data number of point, edges/faces and elements.</p><p>Call:</p><p>Will be called autimatically by display operator.</p><p>One can force it by</p><pre class="language-matlab">obj.disp;
</pre><pre class="codeinput">            <span class="comment">% (c) 2013 Uwe Pr&uuml;fert</span>
            <span class="keyword">if</span> isscalar(obj)
                <span class="keyword">if</span>  isempty(obj.p)
                    fprintf([<span class="string">'    Empty grid object of class '</span>,class(obj),<span class="string">'\n'</span>]);
                <span class="keyword">else</span>
                    disp([<span class="string">'    Grid object of class '</span>,class(obj), <span class="string">' with'</span>])
                    fprintf(<span class="string">'    %d mesh points\n'</span>,obj.nPoints);
                    fprintf(<span class="string">'    %d edges/lateral faces \n'</span>,obj.nEdges);
                    fprintf(<span class="string">'    %d elements.\n\n'</span>,obj.nElements);
                <span class="keyword">end</span>
            <span class="keyword">elseif</span> isvector(obj)
                fprintf(<span class="string">'    [%d x %d] grid object.\n'</span>,size(obj,1),size(obj,2));
                <span class="keyword">for</span> k = 1:length(obj)
                    fprintf(<span class="string">'\nGrid %d:'</span>,k);
                    disp(obj(k));
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                fprintf(<span class="string">'    [%d x %d] grid object.\n'</span>,size(obj,1),size(obj,2));
                <span class="keyword">for</span> k = 1:size(obj,1)
                    <span class="keyword">for</span> l = 1:size(obj,2)
                        fprintf(<span class="string">'\nGrid (%d,%d):'</span>,k,l);
                        disp(obj(k,l));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> makeBoundaryMatrix(obj,varargin)
</pre><h2 id="15">makeBoundaryMatrix</h2><p>IN:self,double[,double,...] OUT:none</p><p>Method that combines boundary definition vectors (PDETOOL style) to a "boundary matrix" that will be written into the property b.</p><p>Call :</p><pre>   gridd.makeBoundaryMatrix(b1,b2,...,bn)</pre><p>The number of arguments must be one (same boundary condition on <b>all</b> boundary segments or the same as the number of boundary segments. Note that makeBoundaryMatrix creates only a data structure that stores boundary conditon definition vectors. The boundary conditons vectors should be created with specialized methods as e.g. gridd.dirichletBC.</p><p>See also pde.setBoudaryCondition</p><pre class="codeinput">            <span class="comment">% (c) 2013 Uwe Pr&uuml;fert</span>
            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1
                    throw(obj.wrongNumberOfBoundaryConditions);
                <span class="keyword">case</span> 2
                    <span class="comment">% one for all</span>
                    bound = varargin{1};
                    <span class="keyword">for</span> k = 2:obj.nBoundarySegments
                        k1 = size(bound,2);
                        k2 = size(varargin{1},2);
                        bound(:,k1+1:k1+k2) =  varargin{1};
                    <span class="keyword">end</span>
                    obj.b = bound;
                    n = size(obj.b,2);
                <span class="keyword">otherwise</span>
                    <span class="comment">% every segment must have an entry</span>
                    <span class="keyword">if</span> obj.nBoundarySegments == nargin-1
                        bound = varargin{1};
                        <span class="keyword">for</span> k = 2:length(varargin)
                            k1 = size(bound,2);
                            k2 = size(varargin{k},2);
                            bound(1:size(varargin{k},1),k1+1:k1+k2) = varargin{k};
                        <span class="keyword">end</span>
                        obj.b = bound;
                        n = size(obj.b,2);
                    <span class="keyword">else</span>
                        fprintf([<span class="string">'Number of boundary segements is '</span>,<span class="keyword">...</span>
                            num2str(nargin-1),<span class="string">',\n'</span>]);
                        fprintf([<span class="string">'but must be '</span>,<span class="keyword">...</span>
                            num2str(obj.nBoundarySegments),<span class="string">'\n'</span>]);
                        obj.wrongNumberOfBoundaryConditions.throwAsCaller;
                    <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> obj.nBoundarySegments~=n
                throw(obj.wrongNumberOfBoundaryConditions);
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> b = dirichletBC(obj,h,r)
</pre><pre class="codeinput">            <span class="comment">%</span>
            <span class="comment">% dirichletBC</span>
            <span class="comment">%</span>
            <span class="comment">% IN:self,char[,char] OUT: double</span>
            <span class="comment">%</span>
            <span class="comment">% Method that codes a Diichlet boundary condition</span>
            <span class="comment">%</span>
            <span class="comment">% Arguments are h (optional) and r.</span>
            <span class="comment">% If used with one argument, $h=1$ is assumed. However, there may be</span>
            <span class="comment">% application where the user want to set $h$ to another value.</span>
            <span class="comment">%</span>
            <span class="comment">% Note that dirichletBC defines "real" Dirichet boundary conditions, not</span>
            <span class="comment">% stiff spring approximation of Dirichlet BCs by Robin BCs.</span>
            <span class="comment">%</span>
            <span class="comment">% Call:</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.dirichletBC('0')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.dirichletBC('1','0')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.dirichletBC('sin(s)')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.dirichletBC('x.^2+y.^2')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.dirichletBC('myfun(x,y)')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.dirichletBC(1)</span>
            <span class="comment">%</span>
</pre><h2 id="18">dirichletBC</h2><p>IN:self,char[,char] OUT: double</p><p>Method that codes the boundary condition</p><p><img src="gridd_eq01100498836466022343.png" alt="$$h\,y = r$$"></p><p>Arguments are h (optional) and r. If used with one argument, <img src="gridd_eq17348141878797291424.png" alt="$h=1$"> is assumed. However, there may be application where the user want to set <img src="gridd_eq08062630503172331818.png" alt="$h$"> to another value.</p><p>Note that dirichletBC defines "real" Dirichet boundary conditions, not stiff spring approximation of Dirichlet BCs by Robin BCs.</p><p>Call:</p><pre>   b = gridd.dirichleBC  % to formally define a BC</pre><pre>   b = gridd.dirichletBC('0')</pre><pre>   b = gridd.dirichletBC('1','0')</pre><pre>   b = gridd.dirichletBC('sin(s)')</pre><pre>   b = gridd.dirichletBC('x.^2+y.^2')</pre><pre>   b = gridd.dirichletBC('myfun(x,y)')</pre><pre>   b = gridd.dirichletBC(1)</pre><pre class="codeinput">            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1
                    b = obj.boundaryCondition([],[],<span class="string">'0'</span>,<span class="string">'0'</span>);
                <span class="keyword">case</span> 2
                    <span class="keyword">switch</span> class(h)
                        <span class="keyword">case</span> <span class="string">'double'</span>
                            h = num2str(h);
                        <span class="keyword">case</span> <span class="string">'char'</span>
                            <span class="comment">% ok</span>
                        <span class="keyword">otherwise</span>
                            throw(obj.wrongClass)
                    <span class="keyword">end</span>
                    b = obj.boundaryCondition([],[],<span class="string">'1'</span>,h);
                <span class="keyword">case</span> 3
                    <span class="keyword">switch</span> class(h)
                        <span class="keyword">case</span> <span class="string">'double'</span>
                            h = num2str(h);
                        <span class="keyword">case</span> <span class="string">'char'</span>
                            <span class="comment">% ok</span>
                        <span class="keyword">otherwise</span>
                            throw(obj.wrongClass)
                    <span class="keyword">end</span>
                    <span class="keyword">switch</span> class(r)
                        <span class="keyword">case</span> <span class="string">'double'</span>
                            h = num2str(r,8); <span class="comment">% 8-digits</span>
                        <span class="keyword">case</span> <span class="string">'char'</span>
                            <span class="comment">% ok</span>
                        <span class="keyword">otherwise</span>
                            obj.wrongClass.throwAsCaller;
                    <span class="keyword">end</span>
                    b = obj.boundaryCondition([],[],h,r);
                <span class="keyword">otherwise</span>
                    obj.wrongNumberInputs.throwAsCaller;
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> b = neumannBC(obj,g)
</pre><pre class="codeinput">            <span class="comment">%</span>
            <span class="comment">%  neumannBC</span>
            <span class="comment">%</span>
            <span class="comment">%  IN:self,char OUT: double</span>
            <span class="comment">%</span>
            <span class="comment">% Mehod that codes Neumann boundary condition.</span>
            <span class="comment">%</span>
            <span class="comment">% Call:</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.neumanBC('1')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.neumanBC('sin(s)')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.neumanBC('x.^2+y.^2')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.neumanBC('myfun(x,y)')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = gridd.neumanBC(1)</span>
            <span class="comment">%</span>
            <span class="comment">% The argument must be an evaluable term, where the indepented variables</span>
            <span class="comment">% must be x,y,z, (if applicable)  or s (arclenght parameter, only 2D).</span>
            <span class="comment">%</span>
</pre><h2 id="21">neumannBC</h2><p>IN:self,char OUT: double</p><p>Mehod that codes the boundary condition</p><p><img src="gridd_eq07482307770705378964.png" alt="$$\vec{n}\cdot\nabla (c\cdot y) = g$$"></p><p>Call:</p><pre>   b = gridd.neumanBC('1')</pre><pre>   b = gridd.neumanBC('sin(s)')</pre><pre>   b = gridd.neumanBC('x.^2+y.^2')</pre><pre>   b = gridd.neumanBC('myfun(x,y)')</pre><pre>   b = gridd.neumanBC(1)</pre><p>The argument must be an evaluable term, where the indepented variables must be x,y,z, (if applicable)  or s (arclenght parameter, only 2D).</p><pre class="codeinput">            b = robinBC(obj,0,g);
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> b = robinBC(obj,q,g)
</pre><pre class="codeinput">            <span class="comment">%</span>
            <span class="comment">% robinBC</span>
            <span class="comment">%</span>
            <span class="comment">% IN:self,char,char OUT: double</span>
            <span class="comment">%</span>
            <span class="comment">% Method that codes Robin boundary condition.</span>
            <span class="comment">%</span>
            <span class="comment">% Arguments are q and g.</span>
            <span class="comment">%</span>
            <span class="comment">% Call:</span>
            <span class="comment">%</span>
            <span class="comment">%     b = obj.robinBC('0')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = obj.robinBC('1','0')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = obj.robinBC('0','sin(s)')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = obj.robintBC('1','x.^2+y.^2')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = obj.robinBC('myfun1(s)','myfun2(x,y)')</span>
            <span class="comment">%</span>
            <span class="comment">%     b = obj.robinBC(1e3,0)</span>
            <span class="comment">%</span>
</pre><h2 id="25">robinBC</h2><pre>IN:self,char,char OUT: double</pre><p>Method that codes the boundary condition <img src="gridd_eq16753707070151405593.png" alt="$\vec{n}\nabla \cdot ( c\cdot y) + q = g$">. Arguments are q and g.</p><p>Call:</p><pre>   b = obj.robinBC('0')</pre><pre>   b = obj.robinBC('1','0')</pre><pre>   b = obj.robinBC('0','sin(s)')</pre><pre>   b = obj.robintBC('1','x.^2+y.^2')</pre><pre>   b = obj.robinBC('myfun1(s)','myfun2(x,y)')</pre><pre>   b = obj.robinBC(1e3,0)</pre><pre class="codeinput">            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1
                    b = obj.boundaryCondition();
                <span class="keyword">case</span> 2
                    <span class="keyword">switch</span> class(q)
                        <span class="keyword">case</span> <span class="string">'double'</span>
                            q = num2str(q);
                        <span class="keyword">case</span> <span class="string">'char'</span>
                            <span class="comment">% ok</span>
                        <span class="keyword">otherwise</span>
                            throw(obj.wrongClass)
                    <span class="keyword">end</span>
                    b = obj.boundaryCondition(q);
                <span class="keyword">case</span> 3
                    <span class="keyword">switch</span> class(q)
                        <span class="keyword">case</span> <span class="string">'double'</span>
                            q = num2str(q);
                        <span class="keyword">case</span> <span class="string">'char'</span>
                            <span class="comment">% ok</span>
                        <span class="keyword">otherwise</span>
                            throw(obj.wrongClass)
                    <span class="keyword">end</span>
                    <span class="keyword">switch</span> class(g)
                        <span class="keyword">case</span> <span class="string">'double'</span>
                            g = num2str(g);
                        <span class="keyword">case</span> <span class="string">'char'</span>
                            <span class="comment">% ok</span>
                        <span class="keyword">otherwise</span>
                            throw(obj.wrongClass)
                    <span class="keyword">end</span>
                    b = obj.boundaryCondition(q,g);
                <span class="keyword">otherwise</span>
                    throw(obj.wrongNumberInputs)
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> val = point2Center(obj,y)
</pre><pre class="codeinput">            <span class="comment">% point2Center</span>
            <span class="comment">% IN self,double OUT: double</span>
            <span class="comment">%</span>
            <span class="comment">% Method that evaluates a function given at the nodes of the grid at the</span>
            <span class="comment">% centers of every elements. Argument must be a vector of length #points.</span>
            <span class="comment">% The  result is a row vector of length #elements.</span>
            <span class="comment">%</span>
            <span class="comment">% Call:</span>
            <span class="comment">%</span>
            <span class="comment">%    y2 = obj.point2Center(y1)</span>
            <span class="comment">%</span>
</pre><h2 id="28">point2Center</h2><p>IN self,double OUT: double</p><p>Method that evaluates a function given at the nodes of the grid at the centers of every elements. Argument must be a vector of length #points. The  result is a row vector of length #elements.</p><p>Call:</p><pre>  y2 = obj.point2Center(y1)</pre><pre class="codeinput">            <span class="keyword">if</span> ~isvector(y)
                obj.wrongFormat.throwAsCaller;
            <span class="keyword">elseif</span> length(y)==obj.nElements
                MException(<span class="string">'GRIDD:OPNOSENSE'</span>,<span class="keyword">...</span>
                    <span class="string">'Size of y is already nElements. Check your code!'</span>).throwAsCaller;
            <span class="keyword">elseif</span> ~length(y)==obj.nPoints
                MException(<span class="string">'GRIDD:OPNOSENSE'</span>,<span class="keyword">...</span>
                    <span class="string">'Size of y is not nPoints.'</span>).throwAsCaller;
            <span class="keyword">end</span>

            y = y(:);

            <span class="keyword">switch</span> obj.nPointsInElements
                <span class="keyword">case</span> 2
                   val = 0.5*sum(y(obj.t(1,:))+y(obj.t(2,:)));
                <span class="keyword">case</span> 3
                   val = (y(obj.t(1,:))+ <span class="keyword">...</span>
                            y(obj.t(2,:))+ <span class="keyword">...</span>
                            y(obj.t(3,:)))/3;
                <span class="keyword">case</span> 4
                   val = 0.25*(y(obj.t(1,:)) + <span class="keyword">...</span>
                            y(obj.t(2,:))+ <span class="keyword">...</span>
                            y(obj.t(3,:))+ <span class="keyword">...</span>
                            y(obj.t(4,:)));
                <span class="keyword">case</span> 6
                    val =(y(obj.t(1,:)) + <span class="keyword">...</span>
                          y(obj.t(2,:)) + <span class="keyword">...</span>
                          y(obj.t(3,:)) + <span class="keyword">...</span>
                          y(obj.t(4,:)) + <span class="keyword">...</span>
                          y(obj.t(5,:)) + <span class="keyword">...</span>
                          y(obj.t(6,:)))/6;
                <span class="keyword">otherwise</span>
                    MException(<span class="string">'PDE:point2Center:UnexpectedNumber'</span>,<span class="keyword">...</span>
                        <span class="string">'Unexpected number of points in element'</span>).throw;
            <span class="keyword">end</span>
            <span class="comment">% Row vector</span>
            val = val(:)';
            <span class="keyword">if</span> length(val)~=obj.nElements
                MException(<span class="string">'GRIDD:INTERNAL'</span>,<span class="string">'You found a bug.'</span>).throw;
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> val = center2Point(obj,y)
</pre><h2 id="30">center2Point</h2><p>IN self,double OUT: double</p><p>Method that evaluates a function given at the nodes of the grid at the centers of every elements. Argument must be a vector of length #points. The result is a row vector of length #elements.</p><p>Call:</p><pre class="language-matlab">y2 = obj.point2Center(y1)
</pre><pre class="codeinput">            <span class="comment">% (c) 2014 Uwe Pr&uuml;fert</span>
            <span class="keyword">if</span> ~isvector(y)
                obj.wrongFormat.throwAsCaller;
            <span class="keyword">elseif</span> length(y)==obj.nPoints
                MException(<span class="string">'GRIDD:OPNOSENSE'</span>,<span class="keyword">...</span>
                    <span class="string">'Size of y is already nPoints. Check your code!'</span>).throwAsCaller;
            <span class="keyword">elseif</span> ~length(y)==obj.nElements
                MException(<span class="string">'GRIDD:OPNOSENSE'</span>,<span class="keyword">...</span>
                    <span class="string">'Size of y is not nElements.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            val = obj.center2PointMatrix*(y(:));
            val = val(:)'; <span class="comment">% Row vector.</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> varargout = nearestPointInGrid(obj,points)
</pre><h2 id="32">nearestPointInGrid</h2><p>IN:self,double OUT:double[,double]</p><p>Method that computes to every point given in argument the point with the smallest distance. The argument must be a matrix of size #space dimension x n. n &gt;0. Output can be the matrix of points and additional the indeces of points in grid.</p><p>Call:</p><pre>   val = obj.nearesPointInGrid(p)</pre><pre>   [val,indx] = obj.nearesPointInGrid(p)</pre><pre class="codeinput">            indx = zeros(size(points,2),1);
            val = zeros(size(points,2),1);
            <span class="keyword">for</span> k = 1:size(points,2)
                [val(k),indx(k)] = min(sum((obj.p-points(:,k)*ones(1,obj.nPoints)).^2));
            <span class="keyword">end</span>
            <span class="keyword">switch</span> nargout
                <span class="keyword">case</span> 1
                    varargout{1} = indx;
                <span class="keyword">case</span> 2
                    varargout{1} = val;
                    varargout{2} = indx;
                <span class="keyword">otherwise</span>
                    <span class="comment">% ignore</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> val = midpts(obj)
</pre><h2 id="34">midpts</h2><p>IN self OUT: double</p><p>Method that computes the coordimnates of the centers of every element, i.e. the barycenters</p><p>Call:</p><pre>  p = obj.midpts</pre><pre class="codeinput">        <span class="comment">% (c) 2013 by Uwe Pr&uuml;fert</span>
            val = obj.p(:,obj.t(1,:))<span class="keyword">...</span>
                +obj.p(:,obj.t(2,:));
            <span class="keyword">for</span> k = 3:obj.nPointsInElements
                val =  val+obj.p(:,obj.t(k,:));
            <span class="keyword">end</span>
            val = 1/obj.nPointsInElements*val;
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> E = point2CenterMatrix(obj)
</pre><h2 id="36">point2CenterMatrix</h2><p>IN:self OUT:double</p><p>Method that computes the transformation matrix for meshpoint to center of elements transformation.</p><pre>   y2 = M*y1</pre><p>is the same as</p><pre>   y2 = obj.point2Center(y1)</pre><p>Call:</p><pre>   val = obj.point2CenterMatrix</pre><p>Works only for linear FE exactly. Overwrite it for P2-elements etc. It is useful if you want to switch between L1-L0 FEs.</p><pre class="codeinput">            idx1 = reshape(obj.t(1:obj.nPointsInElements,:),1,obj.nElements*obj.nPointsInElements);
            idx2 = reshape(repmat(1:obj.nElements,obj.nPointsInElements,1),<span class="keyword">...</span>
                1,obj.nElements*obj.nPointsInElements);
            E = sparse(idx2,idx1,ones(1,obj.nPointsInElements*obj.nElements),<span class="keyword">...</span>
                obj.nElements,obj.nPoints)/obj.nPointsInElements;
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> E = center2PointMatrix(obj)
</pre><h2 id="38">center2PointMatrix</h2><p>IN:self OUT:double</p><p>Returns the transformation matrix barycenters to nodes. Uses linear interpoaltion. Call:   val = obj.center2PointMatrix</p><pre class="codeinput">            idx1 = reshape(obj.t(1:obj.nPointsInElements,:),<span class="keyword">...</span>
                1,obj.nElements*obj.nPointsInElements);
            idx2 = reshape(repmat(1:obj.nElements,obj.nPointsInElements,1),<span class="keyword">...</span>
                1,obj.nElements*obj.nPointsInElements);

            E = sparse(<span class="keyword">...</span>
                idx2,<span class="keyword">...</span>
                idx1,<span class="keyword">...</span>
                reshape(ones(obj.nPointsInElements,1)*ones(1,obj.nElements),1,obj.nPointsInElements*obj.nElements),<span class="keyword">...</span>
                obj.nElements,obj.nPoints)';
            E = sparse(1:obj.nPoints,1:obj.nPoints,1./sum(E,2))*E;
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> setBoundarySegmentNumber(obj,indx,number,varargin)
</pre><h2 id="40">setBoundarySegemntNumber</h2><p>IN:self,double,double[,char]</p><p>Sets the number of the elements in indx to number.</p><p>Call   obj.setBoundarySegmentNumber(indexOfBoundaryElements,...                                  NewNumber,...                                  ['force'])</p><p>'force' ignores the existing numbering. Otherwise, a new segment will be created if NewNumber already exists.</p><pre class="codeinput">            <span class="keyword">if</span> isempty(indx)
                <span class="comment">% Nothing to do</span>
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            force = false;
            <span class="comment">% Handle additional parameters</span>
            <span class="keyword">switch</span> length(varargin)
                <span class="keyword">case</span> 1
                    <span class="keyword">if</span> strcmp(varargin{1},<span class="string">'force'</span>)
                        force = true;
                    <span class="keyword">end</span>
                <span class="keyword">otherwise</span>
            <span class="keyword">end</span>

            <span class="comment">% Some tests</span>
            numbers = unique(obj.e(5,:));
            <span class="keyword">if</span> max(numbers)~=obj.nBoundarySegments
                warning(<span class="string">'gridd: Warning: Boundary numbering inconsistent.\n'</span>);
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~isscalar(number)||number~=round(number)||number&lt;=0
                obj.wrongFormat.throwAsCaller;
            <span class="keyword">end</span>

            numbersAlreadyGiven = unique(obj.t(end,:));
            <span class="keyword">if</span> ismember(number,numbersAlreadyGiven)&amp;&amp;~force
                <span class="comment">% number is already given, we chose another one</span>
                warning([<span class="string">'The number '</span>,num2str(number),<span class="string">' was already given'</span>,<span class="keyword">...</span>
                    <span class="string">' Set it to '</span>,num2str(number+1),<span class="string">'.'</span>])
                number = max(numbersAlreadyGiven)+1;
            <span class="keyword">end</span>
            obj.e(end,indx) = number;
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> setSubdomainNumber(obj,indx,number,varargin)
</pre><h2 id="42">setSubdomainNumber</h2><p>IN: self,double|logical,double[,char] OUT.self</p><p>Method that sets the subdomain number to a user defined value.</p><p>In OOPDE, every element has a subdomain number (similar to the boundary segment number of edges). By default it is set to one. Using this method, you can set it to user defined values to define subdomains, where, for instance, coefficient functions have different  values. Arguments are indeces of elements, the subdomain number and the optinal argument 'force'. indx is a vector of class logical with length obj.nElements or a vector of class double with length &lt;= obj.nElements wich gives the number of elements to be marked. max(indx) must be smaller than obj.nElements Set 'force' to force a numbering, i.e. if you wish to reset a subdomain setting.</p><p>Call:</p><pre>     obj.setSubdomainNumber(1:22,2)</pre><pre>     obj.setSubdomainNumber(indx,1,'force')</pre><pre>     obj.setSubdomainNumber([true true false true],2)</pre><pre class="codeinput">            <span class="keyword">if</span> isempty(indx)
                <span class="comment">% Nothing to do</span>
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            force = false;
            <span class="comment">% Handle additional parameters</span>
            <span class="keyword">switch</span> length(varargin)
                <span class="keyword">case</span> 1
                    <span class="keyword">if</span> strcmp(varargin{1},<span class="string">'force'</span>)
                        force = true;
                    <span class="keyword">end</span>
                <span class="keyword">otherwise</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> length(indx)&gt;obj.nElements
                obj.wrongFormat.throwAsCaller;
                <span class="comment">% Cannot be more elements as in mesh</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> isa(indx,<span class="string">'logical'</span>)&amp;&amp;length(indx)~=obj.nElements
                obj.wrongFormat.throwAsCaller;
                <span class="comment">% In this case it mus have the same size</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> isnumeric(indx)&amp;&amp;max(indx)&gt;obj.nElements
                MException(<span class="string">'gridd:index'</span>,<span class="keyword">...</span>
                    <span class="string">'Index must be in range of 1..nElements.'</span>).throwAsCaller;
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~isscalar(number)||number~=round(number)||number&lt;=0
                obj.wrongFormat.throwAsCaller;
            <span class="keyword">end</span>

            numbersAlreadyGiven = unique(obj.t(end,:));
            <span class="keyword">if</span> ismember(number,numbersAlreadyGiven)&amp;&amp;~force
                <span class="comment">% number is already given, we chose another one</span>
                warning([<span class="string">'The number '</span>,num2str(number),<span class="string">' was already given'</span>,<span class="keyword">...</span>
                    <span class="string">' Set it to '</span>,num2str(number+1),<span class="string">'.'</span>])
                number = max(numbersAlreadyGiven)+1;
            <span class="keyword">end</span>
            obj.t(end,indx) = number;
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> val = chi(obj,N)
</pre><pre class="codeinput">            <span class="comment">% chi</span>
            <span class="comment">% IN: double OUT: double</span>
            <span class="comment">%</span>
            <span class="comment">% This method implements an indicator function on the elements of the grid.</span>
            <span class="comment">% Gives back a vector of length obj.nElements where value is one if the</span>
            <span class="comment">% elements belongs to subdomain number N and zero otherwise.</span>
            <span class="comment">%</span>
            <span class="comment">% Call:</span>
            <span class="comment">%</span>
            <span class="comment">%    val = obj.chi(2)</span>
            <span class="comment">%</span>
            <span class="comment">% for setting val to one on subdomain 2 and to zero on all</span>
            <span class="comment">% other subdomains.</span>
</pre><h2 id="45">chi</h2><p>IN: double OUT: double</p><p>This method implements an indicator function on the elements of the grid. Gives back a vector of length obj.nElements where value is one if the elements belongs to subdomain number N and zero otherwise. In mathematical sense, it represents <img src="gridd_eq03268417114113043985.png" alt="$\chi_{\Omega_N}(x)$">.</p><p>Call:</p><pre>  val = obj.chi(2)</pre><p>for setting val to one on subdomain 2 and to zero on all other subdomains.</p><pre class="codeinput">            val = double(obj.t(end,:)==N);
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> refineUniformly(obj,refines)
</pre><h2 id="47">refineUniformly</h2><p>IN:double OUT:self</p><p>Refines the mesh N times uniformly.</p><p>Call:</p><pre>     obj.refineUniformly(3)</pre><p>to refime the mesh three times.</p><pre class="codeinput">            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1
                    n = 1;
                <span class="keyword">case</span> 2
                    n = refines;
                <span class="keyword">otherwise</span>
                    obj.wrongNumberInputs.throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">for</span> k = 1:n
                obj.refineMesh;
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> rotateMesh(obj,varargin)
</pre><pre class="codeinput">            <span class="comment">% rotateMesh</span>
            <span class="comment">% IN:self,cdouble[,double,double,double] OUT:self</span>
            <span class="comment">%</span>
            <span class="comment">% Method that rotates the points of a mesh. The method makes</span>
            <span class="comment">% only sense if the dimension of the object is 2 or 3. In 2D,</span>
            <span class="comment">% the argument is the rotation angle (positive means</span>
            <span class="comment">% counter-clockwise). In 3D, the first three arguments are</span>
            <span class="comment">% coordinates of the rotation axis (as vector from the origing)</span>
            <span class="comment">% and the fourth argument is the rotation angle.</span>
            <span class="comment">%</span>
            <span class="comment">% Call</span>
            <span class="comment">%</span>
            <span class="comment">%       obj.rotateMesh(alpha)</span>
            <span class="comment">%       obj.rotateMesh(n1,n2,n3,alpha)</span>
            <span class="comment">%       obj.rotateMesh(x0,y0,z0,n1,n2,n3,alpha)</span>
            <span class="comment">%</span>
            <span class="comment">% Example</span>
            <span class="comment">%</span>
            <span class="comment">%       obj.rotateMesh(0,0,1,pi/4)</span>
            <span class="comment">%</span>
            <span class="comment">% rotates a 3D object around the z axis.</span>
</pre><h2 id="50">rotateMesh</h2><p>IN:self,cdouble[,double,double,double] OUT:self</p><p>Method that rotates the points of a mesh. The method makes only sense if the dimension of the object is 2 or 3. In 2D, the argument is the rotation angle (positive means counter-clockwise). In 3D, the first three arguments are coordinates of the rotation axis (as vector from the origing) and the fourth argument is the rotation angle.</p><p>Call</p><pre>     obj.rotateMesh(alpha)
     obj.rotateMesh(n1,n2,n3,alpha)
     obj.rotateMesh(x0,y0,z0,n1,n2,n3,alpha)</pre><p>Example</p><pre>     obj.rotateMesh(0,0,1,pi/4)</pre><p>rotates a 3D object around the z axis with angle <img src="gridd_eq12067281337566323439.png" alt="$\alpha = \pi/4$"></p><pre class="codeinput">            <span class="keyword">if</span> isempty(obj.p)
                <span class="comment">% nothing to do</span>
                MException(<span class="string">'GRIDD:SENSELESSACTION'</span>,<span class="keyword">...</span>
                    <span class="string">'You try to rotate a empty grid.'</span>).throwAsCaller;
            <span class="keyword">end</span>
            <span class="keyword">switch</span> obj.spaceDimension
                <span class="keyword">case</span> 1
                    MException(<span class="string">'GRIDD:SENSELESSOPERATION'</span>,<span class="keyword">...</span>
                        <span class="string">'It is not possible to rotate 1D objects.'</span>).trowAsCaller;
                <span class="keyword">case</span> 2
                    <span class="keyword">switch</span> length(varargin)
                        <span class="keyword">case</span> 1 <span class="comment">% only rotate around (0,0)</span>
                            a = mod(varargin{1},2*pi);
                            RX = [cos(a) -sin(a)
                                  sin(a)  cos(a)];

                            obj.p = RX*obj.p;
                        <span class="keyword">case</span> 3 <span class="comment">% rotate around point (x0,y0)</span>
                            <span class="comment">% move object in (0,0)</span>
                            obj.moveMesh(-varargin{1},-varargin{2})


                            a = mod(varargin{3},2*pi);
                            <span class="comment">% rotation matrix</span>
                            RX = [cos(a) -sin(varargin{3})
                                  sin(a)  cos(varargin{3})];

                            <span class="comment">% rotate object</span>
                            obj.p = RX*obj.p;

                            <span class="comment">% move back to (x0,y0)</span>
                            obj.moveMesh(varargin{1},varargin{2})
                        <span class="keyword">otherwise</span>
                            obj.wrongNumberInputs.throwAsCaller;
                    <span class="keyword">end</span>

                <span class="keyword">case</span> 3
                    <span class="keyword">switch</span> length(varargin)
                        <span class="keyword">case</span> 4
                            <span class="comment">% normalize vector</span>
                            n1 = varargin{1}/norm([varargin{1},varargin{2},varargin{3}]);
                            n2 = varargin{2}/norm([varargin{1},varargin{2},varargin{3}]);
                            n3 = varargin{3}/norm([varargin{1},varargin{2},varargin{3}]);

                            a = mod(varargin{4},2*pi);
                            <span class="comment">% rotation matrix</span>
                            RN = [n1^2*(1-cos(a))+cos(a)        n1*n2*(1-cos(a))-n3*sin(a)  n1*n3*(1-cos(a))+n2*sin(a)
                                  n2*n1*(1-cos(a))+n3*sin(a)    n2^2*(1-cos(a))+cos(a)      n2*n3*(1-cos(a))-n1*sin(a)
                                  n3*n1*(1-cos(a))-n2*sin(a)    n3*n2*(1-cos(a))+n1*sin(a)  n3^2*(1-cos(a))+cos(a)];
                            <span class="comment">% rotate</span>
                            obj.p = RN*obj.p;
                        <span class="keyword">case</span> 7
                            <span class="comment">% bring it to (0,0,0)</span>
                            obj.moveMesh(-varargin{1},-varargin{2},-varargin{3})

                            <span class="comment">% normalize vector</span>

                            n1 = varargin{4}/norm([varargin{4},varargin{5},varargin{6}]);
                            n2 = varargin{5}/norm([varargin{4},varargin{5},varargin{6}]);
                            n3 = varargin{6}/norm([varargin{4},varargin{5},varargin{6}]);

                            a = mod(varargin{7},2*pi);
                            <span class="comment">% rotation matrix</span>
                            RN = [n1^2*(1-cos(a))+cos(a)        n1*n2*(1-cos(a))-n3*sin(a)  n1*n3*(1-cos(a))+n2*sin(a)
                                  n2*n1*(1-cos(a))+n3*sin(a)    n2^2*(1-cos(a))+cos(a)      n2*n3*(1-cos(a))-n1*sin(a)
                                  n3*n1*(1-cos(a))-n2*sin(a)    n3*n2*(1-cos(a))+n1*sin(a)  n3^2*(1-cos(a))+cos(a)];
                            <span class="comment">% rotate</span>
                            obj.p = RN*obj.p;
                            obj.moveMesh(varargin{1},varargin{2},varargin{3})
                        <span class="keyword">otherwise</span>
                            obj.wrongNumberInputs.throwAsCaller;
                    <span class="keyword">end</span>
                    <span class="comment">%</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> moveMesh(obj,varargin)
</pre><h2 id="52">moveMesh</h2><p>IN:self, double, double, double</p><p>Moves mesh in direction v. v must be a vector of length obj.spaceDimension.</p><p>In a second form the arguments is a list of dx dy dz, where the number of arguments must coincine with the dimension of the space. Call</p><pre class="language-matlab">obj.moveMesh(v)
or
obj.moveMesh(dx,dy,dz) <span class="comment">%3D</span>
obj.moveMesh(dx,dy) <span class="comment">%2D</span>
obj.moveMesh(dx) <span class="comment">%1D</span>
</pre><pre class="codeinput">            <span class="keyword">switch</span> obj.spaceDimension
                <span class="keyword">case</span> 1
                    <span class="keyword">if</span> nargin==2
                        obj.p(1,:) = obj.p(1,:)+varargin{1};
                    <span class="keyword">else</span>
                        obj.wrongFormat.throwAsCaller;
                    <span class="keyword">end</span>
                <span class="keyword">case</span> 2
                    <span class="keyword">if</span> nargin == 2 &amp;&amp; length(varargin{1}) == 2
                        obj.p(1,:) = obj.p(1,:)+varargin{1}(1);
                        obj.p(2,:) = obj.p(2,:)+varargin{1}(2);
                    <span class="keyword">elseif</span> nargin == 3
                        obj.p(1,:) = obj.p(1,:)+varargin{1};
                        obj.p(2,:) = obj.p(2,:)+varargin{2};
                    <span class="keyword">else</span>
                        obj.wrongFormat.throwAsCaller;
                    <span class="keyword">end</span>

                <span class="keyword">case</span> 3
                    <span class="keyword">if</span> nargin == 2 &amp;&amp; length(varargin{1}) == 3
                        obj.p(1,:) = obj.p(1,:)+varargin{1}(1);
                        obj.p(2,:) = obj.p(2,:)+varargin{1}(2);
                        obj.p(3,:) = obj.p(3,:)+varargin{1}(3);
                    <span class="keyword">elseif</span> nargin == 4
                        obj.p(1,:) = obj.p(1,:)+varargin{1};
                        obj.p(2,:) = obj.p(2,:)+varargin{2};
                        obj.p(3,:) = obj.p(3,:)+varargin{3};
                    <span class="keyword">else</span>
                        obj.wrongFormat.throwAsCaller;
                    <span class="keyword">end</span>
                <span class="keyword">otherwise</span>
                    MException(<span class="string">'GRIDD:UNKNOWNERROR'</span>,<span class="string">'This should never hapen.'</span>)
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> scaleMesh(obj,scale)
</pre><h2 id="54">scaleMesh</h2><p>IN scaleFactor OUT:self</p><p>This method scales up or down the geometry.</p><p>Example:</p><pre class="language-matlab">grid = UnitSquare(0.1)
grid.scale(2)
</pre><p>produces the square (0,2)x(0,2).</p><p>ScaleFactor can be a scalar double between 1e-3 and 1e3.</p><pre class="codeinput">            <span class="keyword">if</span> scale&gt;1e-3 &amp;&amp; scale &lt; 1e3
                obj.p = obj.p*scale;
            <span class="keyword">else</span>
                MException(<span class="string">'GRIDD:WRONGPARAMETER'</span>,<span class="keyword">...</span>
                    <span class="string">'Scale factor too small or to large.'</span>).throwAsCaller;
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> u2 = interpolate(obj,p1,p2,u1)
</pre><h2 id="56">interpolate</h2><p>IN:double,double,double OUT:double</p><p>Method that interpolates data from points points.</p><p>Call        u2 = interpolate(p1,p2,u1)</p><p>p1 is a the p field of an grid object with associated data u1. p2 is a p field of a further grid object.</p><pre class="codeinput">            dim = size(p1,1);
            <span class="keyword">switch</span> dim
                <span class="keyword">case</span> 1
                    u2 = interp1(p1,u1,p2,<span class="string">'linear'</span>);
                <span class="keyword">case</span> {2,3}
                    u1 = u1(:); <span class="comment">% force to be a column vector</span>
                    <span class="keyword">if</span> length(u1)==size(p1,2)
                        interpolant = scatteredInterpolant(p1',u1,<span class="string">'linear'</span>,<span class="string">'none'</span>);
                        u2 = interpolant(p2');
                        u2 = u2(:)';
                    <span class="keyword">else</span>
                        MException(<span class="string">'GRIDD:WRONGFORMAT'</span>,<span class="keyword">...</span>
                        <span class="string">'Input has the wrong format, check it.'</span>).throwAsCaller
                    <span class="keyword">end</span>
                <span class="keyword">otherwise</span>
                    <span class="comment">% ME werfen...</span>
                    MException(<span class="string">'PDE:NOTSUPPORTEDDIM'</span>,<span class="keyword">...</span>
                        <span class="string">'PDE supports only FE in 1D-3D domains'</span>).throwAsCaller;
            <span class="keyword">end</span>

            <span class="comment">% remove points not in the domain,</span>

<span class="comment">% % %             u2(~obj.isPointInDomain(p2)) = NaN;</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> val = getBoundaryPoints(obj)
</pre><h2 id="58">getBoundaryPoints</h2><p>IN self OUT double</p><p>Call</p><pre>  boundaryPoints = obj.getBoundaryPoints</pre><p>Gives back the point on the boundary of a grid but excludes the extended points.</p><pre class="codeinput">            <span class="comment">% (c) 2013 by Uwe Pr&uuml;fert</span>
            <span class="keyword">switch</span> obj.spaceDimension
                <span class="keyword">case</span> 1
                    val = obj.p(:,unique(obj.e(1,:)));
                <span class="keyword">case</span> 2
                    val = obj.p(:,unique(obj.e(1:2,:)));
                <span class="keyword">case</span> 3
                    val = obj.p(:,unique(obj.e(1:3,:)));
                <span class="keyword">otherwise</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> idx = getBoundaryElementsIndex(obj,boundarySegment)
</pre><h2 id="60">getBoundaryElementsIndex</h2><p>IN: self,double OUT:double</p><p>Returns the indeces of boundary segment of the given boundary segment number. Call</p><pre class="language-matlab">indx = obj.getBoundaryElementsIndex(2)
</pre><p>Retuns all boundary elements that belongs to segment number two.</p><pre class="codeinput">            idx = find(obj.e(5,:)==boundarySegment);
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> val = point2CenterB(obj,y)
</pre><h2 id="62">point2CenterB</h2><p>IN:self,double OUT double</p><p>Evaluates the data y(x) on the center of the boundary elements by linear interpolation. point2Center for on the boundary In contrast to midpointsOfBoundaryElements, this method retuns a row vector of lenght obj.nEdges</p><pre class="codeinput">            <span class="comment">% Check data y</span>
            <span class="keyword">if</span> isvector(y)&amp;&amp;length(y)~=obj.nPoints
                MException(<span class="string">'GRIDD:WRONGDATAFORMAT'</span>,<span class="keyword">...</span>
                    <span class="string">'Data y must  have nPoints rows.'</span>).throwAsCaller;
            <span class="keyword">else</span>
                y = y(:); <span class="comment">% Make column vector.</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> ismatrix(y)&amp;&amp;size(y,1)~=obj.nPoints
                 MException(<span class="string">'GRIDD:WRONGDATAFORMAT'</span>,<span class="keyword">...</span>
                    <span class="string">'Data y must  have nPoints rows.'</span>).throwAsCaller;

            <span class="keyword">end</span>

            <span class="keyword">switch</span> obj.spaceDimension
                <span class="keyword">case</span> 1
                    <span class="comment">% Nothing to do, more or less dummy implementation</span>
                    MException(<span class="string">'GRIDD:NOTVALID'</span>,<span class="keyword">...</span>
                        <span class="string">'This method makes no sense for 1D grids'</span>).throwAsCaller;
                <span class="keyword">case</span> 2
                    indexOfPoints = obj.e(1:2,:);
                    val = 0.5*(y(indexOfPoints(1,:),:)+y(indexOfPoints(2,:),:));
                <span class="keyword">case</span> 3
                    <span class="comment">% Triangle faces</span>
                    val = zeros(obj.nEdges,1);
                    indexOfPoints = obj.e(1:3,obj.e(4,:)==0);

                    val(obj.e(4,:)==0) = 1/3*(y(indexOfPoints(1,:),:)<span class="keyword">...</span>
                                            + y(indexOfPoints(2,:),:)<span class="keyword">...</span>
                                            + y(indexOfPoints(3,:),:));
                    <span class="comment">% Rectangle faces</span>
                    indexOfPoints = obj.e(1:4,obj.e(4,:)~=0);
                    val(obj.e(4,:)~=0) = 0.25*(y(indexOfPoints(1,:),:)<span class="keyword">...</span>
                                            +y(indexOfPoints(2,:),:)<span class="keyword">...</span>
                                            +y(indexOfPoints(3,:),:)<span class="keyword">...</span>
                                            +y(indexOfPoints(4,:),:));
            <span class="keyword">end</span>
            val = val(:)';
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> val = midpointsOfBoundaryElements(obj,boundarySegment)
</pre><h2 id="64">midpointsOfBoundaryElements</h2><p>IN: self, double OUT: double</p><p>gives back coordinates of center of boundary elements of k-th boundary segment.</p><pre>   val = obj.midpointsOfBoundaryElements([numberOfBoundarySegment])</pre><p>val is a matrix of dimension N x number of boundary elements or  N x number boundary elements of k-th boundary segment(s).</p><pre class="codeinput">            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1
                    boundarySegment = unique(obj.e(5,:));
                <span class="keyword">case</span> 2
                    <span class="keyword">if</span> isempty(intersect(boundarySegment,unique(obj.e(5,:))))
                        MException(<span class="string">'GRIDD:ARGUMENTSMISSMATCH'</span>,<span class="keyword">...</span>
                            [<span class="string">'The boundary segment'</span>,<span class="keyword">...</span>
                            num2str(numberOfBoundarySegment),<span class="keyword">...</span>
                            <span class="string">' do not exist'</span>]).throwAsCaller
                    <span class="keyword">end</span>
            <span class="keyword">end</span>
            val = [];
            <span class="keyword">for</span> k = 1:length(boundarySegment)
                elementsOfSegment = (obj.e(5,:)==boundarySegment(k));
                <span class="keyword">switch</span> obj.spaceDimension
                    <span class="keyword">case</span> 1
                        indexOfPoints = obj.e(1,elementsOfSegment);
                        val = obj.p(:,indexOfPoints(1,:));
                    <span class="keyword">case</span> 2
                        indexOfPoints = obj.e(1:2,elementsOfSegment);
                        val = [val 0.5*(obj.p(:,indexOfPoints(1,:))+obj.p(:,indexOfPoints(2,:)))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    <span class="keyword">case</span> 3
                        indexOfPoints = obj.e(1:3,elementsOfSegment);
                        val = [val 1/3*(obj.p(:,indexOfPoints(1,:))+obj.p(:,indexOfPoints(2,:))+obj.p(:,indexOfPoints(3,:)))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> index= getBoundaryPointsIndex(obj,boundarySegment)
</pre><h2 id="66">getBoundaryPointsIndex</h2><p>IN self,double OUT double</p><p>Gives back the index of the points on the boundary of a grid.</p><p>Call</p><pre>  index= obj.getBoundaryPointsIndex([2 5])</pre><p>returns the indeces of all points in boundary segmens two and five. Note that in contrast to</p><pre class="language-matlab">getBoundaryPointsIndexPerElement
</pre><p>the result is a vector.</p><pre class="codeinput">            <span class="comment">% (c) 2013 by Uwe Pr&uuml;fert</span>

            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1
                    boundarySegment = unique(obj.e(5,:));
                <span class="keyword">case</span> 2
                    <span class="keyword">if</span> isempty(intersect(boundarySegment,unique(obj.e(5,:))))
                        MException(<span class="string">'GRIDD:ARGUMENTSMISSMATCH'</span>,<span class="keyword">...</span>
                            [<span class="string">'The boundary segment '</span>,<span class="keyword">...</span>
                            num2str(boundarySegment),<span class="keyword">...</span>
                            <span class="string">' do not exist'</span>]).throwAsCaller
                    <span class="keyword">end</span>
            <span class="keyword">end</span>

            index = obj.getBoundaryPointsIndexPerElement(boundarySegment);
            index = unique(index);
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> index= getBoundaryPointsIndexPerElement(obj,boundarySegment)
</pre><h2 id="68">getBoundaryPointsIndexPerElement</h2><p>IN self,double OUT double</p><p>Gives back the index of the points on the boundary of a grid.</p><p>Call</p><pre>  index= obj.getBoundaryPointsIndexPerElement([2 5])</pre><p>returns the indeces of all points in boundary segmens two and five.</p><p>Note that the result is a matrix of size number points in boundary elements x number of boundary elements in the boundary segments the method is called for.</p><pre class="codeinput">            index = [];
            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1
                    boundarySegment = unique(obj.e(5,:));
                <span class="keyword">case</span> 2
                    <span class="keyword">if</span> isempty(intersect(boundarySegment,unique(obj.e(5,:))))
                        MException(<span class="string">'GRIDD:ARGUMENTSMISSMATCH'</span>,<span class="keyword">...</span>
                            [<span class="string">'The boundary segment '</span>,<span class="keyword">...</span>
                            num2str(boundarySegment),<span class="keyword">...</span>
                            <span class="string">' do not exist'</span>]).throwAsCaller
                    <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">for</span> k = 1:length(boundarySegment)
                <span class="keyword">switch</span> obj.spaceDimension
                    <span class="keyword">case</span> 1
                         index = [index obj.e(1,obj.e(5,:)==boundarySegment(k))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    <span class="keyword">case</span> 2
                        <span class="keyword">if</span> obj.isExtended
                            index = [index obj.e([1 2 6],obj.e(5,:)==boundarySegment(k))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                        <span class="keyword">else</span>
                            index = [index obj.e(1:2,obj.e(5,:)==boundarySegment(k))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                        <span class="keyword">end</span>
                    <span class="keyword">case</span> 3
                         index = [index obj.e(1:3,obj.e(5,:)==boundarySegment(k))]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    <span class="keyword">otherwise</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> index = getBoundaryPointsIndexPerSegment(obj,boundarySegment)
</pre><h2 id="70">getBoundaryPointsIndexPerSegment</h2><p>IN self,double OUT double</p><p>Gives bach the index of boundary points of the boundary segment given by the parameter bs.</p><p>Call</p><pre>index= obj.getBoundaryPointsIndex(2)</pre><p>Returns the points that belong to segment number 2.</p><p>Note that if the argument can be a vector. In this case, the index of boundary points of all selected boundary segments are returned, and if there are neighbored bioundary segments, points may occure twice in the list. This is not a bug. Note that the list of indeces is blockwise sorted.</p><pre class="codeinput">            index = [];
            <span class="keyword">for</span> k = 1:length(boundarySegment)
                index = [index unique(obj.getBoundaryPointsIndexPerElement(boundarySegment(k)))'];
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> index= getInnerPointsIndex(obj)
</pre><h2 id="72">getInnerPointsIndex</h2><p>IN:self OUT:double</p><p>Gives back the index of the points not on the boundary of a grid.</p><p>Call</p><pre class="language-matlab">index = obj.getInnerPointsIndex
</pre><pre class="codeinput">            <span class="comment">% (c) 2013 by Uwe Pr&uuml;fert</span>

            index = 1:obj.nPoints;
            index(obj.getBoundaryPointsIndex) = [];
</pre><pre class="codeinput">        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>

    methods(Access = public,<span class="keyword">...</span>
          Abstract = true)
        [sideLength,area] = sideLengthAndArea(obj); <span class="comment">% okay for 1D 2D</span>
    <span class="keyword">end</span>

    methods(Access = private)
        <span class="keyword">function</span> b = boundaryCondition(obj,q,g,h,r)
            <span class="comment">% Defines boundary condition matrix in PDEtool style</span>
            <span class="comment">% Syntax:</span>
            <span class="comment">% b = obj.boundaryCondition            homogenious Neumann BCs</span>
            <span class="comment">% b = obj.boundaryCondition(g)         Neumann BCs</span>
            <span class="comment">% b = obj.boundaryCondition(q,g)       Robin BCs</span>
            <span class="comment">% b = obj.boundaryCondition([],[],h,r) Dirichlet BC</span>
            <span class="comment">%</span>
            <span class="comment">% (c) 2013 by Uwe Pr&uuml;fert</span>

            <span class="comment">% handle the "minimalistic syntax" options</span>
            <span class="keyword">switch</span> nargin
                <span class="keyword">case</span> 1
                    q = <span class="string">'0'</span>;
                    g = <span class="string">'0'</span>;
                    h = [];
                    r = [];
                <span class="keyword">case</span> 2
                    g =  q;
                    q = <span class="string">'0'</span>;
                    h = [];
                    r = [];
                <span class="keyword">case</span> 3
                    h = [];
                    r = [];
                <span class="keyword">case</span> 5
                    <span class="keyword">if</span> ~(((isempty(g)&amp;&amp;isempty(q))&amp;&amp; ~(isempty(h)&amp;&amp;isempty(r)))||<span class="keyword">...</span>
                            (~(isempty(g)&amp;&amp;isempty(q))&amp;&amp; (isempty(h)&amp;&amp;isempty(r))))
                        ME = MException(<span class="string">'obj:WRONGDEFINITION'</span>,<span class="keyword">...</span>
                            <span class="string">'You can define only Dirichlet OR Robin BCs.'</span>);
                        throw(ME);
                    <span class="keyword">end</span>
                <span class="keyword">otherwise</span>
                    throw(obj.wrongNumberInputs)
            <span class="keyword">end</span>
            <span class="keyword">if</span> isa(g,<span class="string">'double'</span>)
                g = num2str(g);
            <span class="keyword">end</span>
            <span class="keyword">if</span> isa(q,<span class="string">'double'</span>)
                q = num2str(q);
            <span class="keyword">end</span>
            <span class="keyword">if</span> isa(r,<span class="string">'double'</span>)
                r = num2str(r);
            <span class="keyword">end</span>
            <span class="keyword">if</span> isa(h,<span class="string">'double'</span>)
                h  = num2str(h);
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(h)&amp;&amp;isempty(r)
                b = 1;                       <span class="comment">% only Neumann BCs</span>
                b(2,1) = 0;
                b(3,1) = length(q);
                b(4,1) = length(g);
                b=[b;double(q)';double(g)'];
            <span class="keyword">elseif</span> isempty(q)&amp;&amp;isempty(g)   <span class="comment">% Dirichlet BCs, setting the Neumann part</span>
                b = 1;                       <span class="comment">% to zero</span>
                b(2,1) = 1;
                b(3,1) = 1;
                b(4,1) = 1;
                b(5,1) = length(h);
                b(6,1) = length(r);
                b(7,1) = 48;
                b(8,1) = 48;
                b = [b;double(h)';double(r)'];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    methods(Access = public,<span class="keyword">...</span>
            Hidden = true)
        <span class="comment">% all methods from handle</span>
        <span class="comment">% intended not to shown...</span>
         addlistener(obj)
         ge(obj)
         le(obj)
         ne(obj)
         notify(obj)
         gt(obj)
         eq(obj)
         findobj(obj)
         findprop(obj)
         lt(obj)
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% gridd
% Abstract  basis class for all grid objects. Defines properties p,e,t for 
% storing points, edges/faces, and triangles/tetraeder/prisms. 
% 
% The property b stores the boundary condition matrix in pdetool style.
%
% Note that you cannot create objects from abstract classes. It is used only
% as a parent class for gridXD classes  and for deriving further user
% classes.
%
%
% gridd provides  methods that be independent from the specific type of
% grid or space dimension.
% 
% Copy style: handle.
%

%%

% Important %% tag. Don't remove it!

% Note
% Since we want ot have a hard-copy method, all properties will be protected. 
% Otherwise, we cannot copy them in derived classes.

%% Inheritance
%
% gridd < handle 
%

classdef (Abstract) gridd < handle     
    
    % Changes:
    % 8/9/2016
    % Change some methods to dependent props. nElements, nPoints, etc.
    % 5/5/2015
    % Add new abstract method sideLengthAndArea that computes the
    % sidelengths and areas of elements. Implement it in gridXd classes!
    %
    % 10/29/2013
    %   "geometrie" property g removed (becuase this version is pdetool free).
    %   nBoundarySegments is now the maximum of numbered boundary
    %   segments, not the number of defined boundaries in obj.b
    %   makeBoundaryMatrix can now be called with only one argument to give
    %   one boundary condition to ALL boundary segments.
    % 2014/08/13
    % Code change in nBoundarySegmenst: Now it gives back the number of
    % different names
    % Now a one parameter call of dirichletBC is possible, e.g.
    % dirichletBC(2) is BC y = 3;
    % 
    % (c) 2013-2016 by Uwe Prüfert 
    
    %% Properties  with SetAccess = protected
    %
    % * p (double) Coordinates of grid points
    % * e (double) Indices of edge points
    % * t (double) Indices of element points
    % * isExtended (logical, *false*)  
    % * b (double) Boundary condition matrix in pdetool-style where
    % char(b) gives the human readable definition of the boundary
    % condition. Will be created by class methods and cannot be edited.
    %
    %
    % For 1D and 3D grids, "edge" stands for all shapes ob boundary 
    % elements and "element" stands for all shapes of elements.
    
    properties(GetAccess = public,...
               SetAccess = protected)
        % 
        % p e t = points, edges triangle, as in PDE tool defined.
        %   
        
        p double            % points
        e double            % edges 
        t double            % triangles  
        b                   % boundary condition cell or double 
    end  
    
    properties(SetAccess = protected,...
               GetAccess = public,...
                  Hidden = true)
              isExtended logical = false  
                            % if expanded then e.g. 
                            % additional points added to p
    end
    
    %% Abstract properties.
    %
    % Redefine it in derived classes!
    %
    % * nPointsInElements (double) number of points in elements. 
    %
    % It may 2 for 1D elements, 3 or 4 for triangles or squares, or 6 for extended
    % triangles, etc.
    
    properties(GetAccess = public,...
               SetAccess = protected,...               
                Abstract = true)
        
        nPointsInElements double 
                            % Number of points in element,...
                            % two in 2D, three or four in 2D,...
                            % four or six in 3D
    end
    
    %%
    % * spaceDimension (double) Dimension of space, 1,2, or 3
    %
    properties(GetAccess = public,...              
                Constant = true,...
                Abstract = true)
        
        spaceDimension double   % Dimension of space, N = {1,2,3}.
    end
    
    %% Dependent properties with GetAccess = public and SetAccess = private
    %         
    % * x (double) All values of X-coordinate
    % * y (double) All values of Y-coordinate (if applicable)
    % * z (double) All values of Z-coordinate (if applicable)
    %
    % * nElements (double) Number of elements in grid
    % * nPoints (double) Number of points in grid
    % * nEdges (double) Number of edge-elements in grid
    %
    % * nBoundarySegments (double) Number of of boundary segments in grid
    % * nBoundaryPoints (double) Number of points on the boundary of grid
    %
    % * nDirichletPoints (double) Number of Dirichlet boundary points
    % * nDirichletBoundarySegments (double) Number of Dirichlet boundary 
    %                                       Segments
    % * nRobinBoundaryElements (double) Number of Robin boundary elements
    % * nRobinBoundarySegments (double) Number of Robin boundary segments
    %
    % * indexOfDirichletBoundarySegments (double) Vector with index of Dirichlet 
    %                                   boundary segments    
    % * indexOfDirichletBoundaryPoints (double) Vector with index of Dirichlet 
    %                                   boundary points
    %
    % * indexOfRobinBoundarySegments (double) Vector with index of Robin boundary
    %                                   segments
    % * indexOfRobinBoundaryElements (double)  Vector with index of Robin
    %                                   boundary elements. In order of
    %                                   boundary segments, i.e. elements of
    %                                   segment 1, ... elements of segment N. 
    %
    % Note that such properties need a get method. 
    
    properties(GetAccess = public,...
               SetAccess = private,...
               Dependent = true)
        
        x                   % x-coordinate of grid nodes
        y                   % y-coordinate of grid nodes
        z                   % z-coordinate of grid nodes
        
        nElements           % number of elements in grid
        nPoints             % number of points/nodes in grid
        nEdges              % number of edges/faces (in 1D always two) 
        
        nBoundarySegments   % number of boundary segments. 
        nBoundaryPoints     % number of boundary points/nodes
        % New in R2018
        nSubDomains         % number of subdomains
        
        nDirichletBoundaryPoints    % number of dirichlet boundary points/nodes       
        nDirichletBoundarySegments % number of Dirichlet boundary Segments
        
        nRobinBoundaryElements  % number of Robin boundary elements
        nRobinBoundarySegments  % number of Robin boundary segments
        
        indexOfDirichletBoundarySegments % index vector of Dirichlet segments
        indexOfDirichletBoundaryPoints   % index vector of Dirichlet boundary points
        indexOfRobinBoundarySegments     % index vector of Robin boundary segments 
        indexOfRobinBoundaryElements     % index vector of Robin boundary elements  
        
    end
    
    properties(   Access = public,...
                  Hidden = true)
        NrPO@double         % Number of points before the mesh extending
                            % M Heim.
    end
    
    properties(SetAccess = protected,...
                  Hidden = true)
        ngpts@double        % number of grid points w/o extended points
         
    end
    
    %% Constant properties
    % Some execption defined as constants. MException objects. Call them with
    % e.g.
    %
    %   obj.wrongNumerInputs.throwAsCaller
    %
    % * wrongNumberInputs (MException) 
    % * wrongFormat (MException) 
    % * wrongClass (MException) 
    % * wrongNumberPoints (MException) 
    % * privateProp (MException) 
    % * noIndexing (MException)  
    % * wrongNumberOfBoundaryConditions (MException)  
    %  
    properties(GetAccess = public,...
                Constant = true)
            
        wrongNumberInputs = MException('GRIDD:WRONGNUMBERINPUTS',...
            'The number of arguments is wrong, check it.');
        wrongFormat = MException('GRIDD:WRONGFORMAT',...
            'Input has the wrong format, check it.');
        wrongClass = MException('GRIDD:WRONGCLASS',...
            'Wrong argument class, check it.');
        wrongNumberPoints = MException('GRIDD:WRONGPOINTS',...
            'Wrong number of points, check it!'); 
        privateProp = MException('GRIDD:PRIVATE',...
            'The property is declared as private or do not exist.'); 
        noIndexing = MException('GRIDD:INDEX',...
            'No arrays of gridd allowed.');
        wrongNumberOfBoundaryConditions = MException(...
            'GRIDD:WRONGBOUNDARYCOND',...
            'The number of boudary conditions in matrix b and in geometry don''t match.')
    end 
    
    methods
        % For dependent properties.      
        
        % The get methods checks if the property should "exist" dependently
        % from the dimension of the space e.i. of the grid. 
        function val = get.x(obj)
            if isempty(obj.p)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end            
            val = obj.p(1,:);            
        end
        
        function val = get.y(obj)
            if isempty(obj.p)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;           
            elseif size(obj.p,1)<2
                MException('GRIDD:NOSUCHPROP',...
                    [num2str(obj.spaceDimension),...
                    'D meshes have no property y.']).throwAsCaller;
            else
                val = obj.p(2,:);
            end
        end
        
        function val = get.z(obj)
            if isempty(obj.p)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;           
            elseif size(obj.p,1)<3
                MException('GRIDD:NOSUCHPROP',...
                    [num2str(obj.spaceDimension),...
                    'D meshes have no property z.']).throwAsCaller;
            else
                val = obj.p(3,:);
            end
        end
        
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
        
        function val = get.nElements(obj)
            if isempty(obj.t)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            val = size(obj.t,2);
        end   
        
        function val = get.nPoints(obj)
            if isempty(obj.p)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            val = size(obj.p,2);            
        end
        
        function val = get.nEdges(obj)
            if isempty(obj.e)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            val = size(obj.e,2);
        end
        
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        
        function val = get.nBoundarySegments(obj)
            if isempty(obj.e)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            val = length(unique(obj.e(5,:)));
        end    
        
        function val = get.nSubDomains(obj)
            val = length(unique(obj.t(end,:)));
        end
        
        function val = get.nBoundaryPoints(obj)  
            if isempty(obj.e)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            if isa(obj,'grid3Dpr')
                N = 4;
            else
                N = size(obj.p,1);
            end
            val = length(find(unique(obj.e(1:N,:))>0));
        end
        
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        
        function val = get.nDirichletBoundaryPoints(obj)
            if isempty(obj.e)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            if isempty(obj.b)
                MException('GRIDD:NOBOUNDARYCONDITION',...
                    'No boundary conditions defined.').throwAsCaller;
            end           
            val = length(unique(obj.indexOfDirichletBoundaryPoints)); 
             
        end
        
        function val = get.nDirichletBoundarySegments(obj)
            if isempty(obj.b)
                MException('GRIDD:NOBOUNDARYCONDITION',...
                    'No boundary conditions defined.').throwAsCaller;
            end
            val = sum(obj.b(2,:)==1);    
             
        end
        
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
              
        function val = get.nRobinBoundaryElements(obj)
            if isempty(obj.e)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            if isempty(obj.b)
                MException('GRIDD:NOBOUNDARYCONDITION',...
                    'No boundary conditions defined.').throwAsCaller;
            end
            val = 0;
            for k = obj.indexOfRobinBoundarySegments
                val = val + sum(obj.e(5,:)==k);
            end 
             
        end
        
        function val = get.nRobinBoundarySegments(obj)
            if isempty(obj.b)
                MException('GRIDD:NOBOUNDARYCONDITION',...
                    'No boundary conditions defined.').throwAsCaller;
            end
            val = sum(obj.b(2,:)==0);
             
        end
        
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        
        function val = get.indexOfDirichletBoundarySegments(obj)
            if isempty(obj.b)
                MException('GRIDD:NOBOUNDARYCONDITION',...
                    'No boundary conditions defined.').throwAsCaller;
            end
            val = find(obj.b(2,:)==1);  
             
        end
        
        function val = get.indexOfDirichletBoundaryPoints(obj)
            
            %Important note:  If Dirichlet boundary segments are
            %neighbored, then common point appears in this list twice.
            
            
            if isempty(obj.e)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            if isempty(obj.b)
                MException('GRIDD:NOBOUNDARYCONDITION',...
                    'No boundary conditions defined.').throwAsCaller;
            end
            val = [];
            switch obj.spaceDimension
                case 1
                    val = obj.e(1:2,1);
                case 2
                    for k = obj.indexOfDirichletBoundarySegments
                        if obj.isExtended
                            indx = unique(obj.e([1 2 6],obj.e(5,:)==k));
                        else
                            indx = unique(obj.e(1:2,obj.e(5,:)==k));
                        end
                        val = [val indx(:)']; %#ok<AGROW>
                    end
                case 3
                    for k = obj.indexOfDirichletBoundarySegments
                        val =  [val unique(obj.e(1:4,obj.e(5,:)==k))]; %#ok<AGROW>
                    end
                     
                    if val(1) == 0
                        val(1) = [];
                    end
            end
             
            val = val(:)'; % row vector
        end
        
        function val = get.indexOfRobinBoundarySegments(obj)
            if isempty(obj.b)
                MException('GRIDD:NOBOUNDARYCONDITION',...
                    'No boundary conditions defined.').throwAsCaller;
            end
            val = find(obj.b(2,:)==0);
             
        end
        
        function val = get.indexOfRobinBoundaryElements(obj)
            if isempty(obj.e)
                MException('GRIDD:NOGRID',...
                    'No grid defined.').throwAsCaller;
            end
            if isempty(obj.b)
                MException('GRIDD:NOBOUNDARYCONDITION',...
                    'No boundary conditions defined.').throwAsCaller;
            end
            val = [];
            for k = obj.indexOfRobinBoundarySegments                
                val = [val find(obj.e(5,:)==k)]; %#ok<AGROW>
            end
             
        end
    end
    
    %% Public methods
    %
    
    methods(Access = public)
            %% gridd
            % IN:nothing OUT:gridd
            %
            % Default constructor method without arguments. 
            %
            % Note that gridd is abstract and makes only sense to derive
            % subclasses. Derived subclasses are
            %
            %
            % 
            % * grid1D      Interval "grids". Only userclass is Interval
            % * grid2D      2D driangle grids. Userclasses are UnitSquare etc.
            % * grid3D      3D tetrahedral grids. Userclasses are Ball etc.
            % * grid3Dpr    3D prism grids. Userclasses are Part3D or
            %               Coil3D
            %
            % Derive further classes if usefull.
            % 
            
        function obj2 = copy(obj1)
            %% copy 
            % IN:self OUT:gridd
            %
            % Hardcopy method.
            %
            % Note it copies only properties p, e, t, and b.   
            % 
            % Call:
            %
            %   obj2 = obj1.copy
            %
            % Override it in derived classes if there are additional
            % (non dependent) properties.
            
            eval(['obj2 = ',class(obj1),';']);         
            if ~isempty(obj1)  
                obj2.p = obj1.p;
                obj2.e = obj1.e;
                obj2.t = obj1.t;
                obj2.b = obj1.b; 
            end
        end
        
        function disp(obj)
            %% disp 
            % IN:self OOU:nothing
            %
            % disp methods. Overrides default disp inherited from handle.
            %
            %   obj.disp    
            %
            % Displays the class and provides data number of point, edges/faces and elements. 
            % 
            % Call:
            %
            % Will be called autimatically by display operator.
            %
            % One can force it by
            % 
            %   obj.disp;
            % 
            
            % (c) 2013 Uwe Prüfert 
            if isscalar(obj)
                if  isempty(obj.p) 
                    fprintf(['    Empty grid object of class ',class(obj),'\n']);
                else
                    disp(['    Grid object of class ',class(obj), ' with'])
                    fprintf('    %d mesh points\n',obj.nPoints);                               
                    fprintf('    %d edges/lateral faces \n',obj.nEdges);                
                    fprintf('    %d elements.\n\n',obj.nElements);                
                end
            elseif isvector(obj)
                fprintf('    [%d x %d] grid object.\n',size(obj,1),size(obj,2));
                for k = 1:length(obj)
                    fprintf('\nGrid %d:',k);
                    disp(obj(k));
                end
            else
                fprintf('    [%d x %d] grid object.\n',size(obj,1),size(obj,2));
                for k = 1:size(obj,1)
                    for l = 1:size(obj,2)
                        fprintf('\nGrid (%d,%d):',k,l);
                        disp(obj(k,l));
                    end
                end
            end
        end         
        
        function makeBoundaryMatrix(obj,varargin)
            %%  makeBoundaryMatrix 
            %
            % IN:self,double[,double,...] OUT:none
            % 
            % Method that combines boundary definition vectors (PDETOOL style)
            % to a "boundary matrix" 
            % that will be written into the property b. 
            % 
            % Call : 
            %
            %     gridd.makeBoundaryMatrix(b1,b2,...,bn)
            % 
            % The number of arguments must be one (same boundary condition on *all* 
            % boundary segments or the same as the number of boundary segments.
            % Note that makeBoundaryMatrix creates only a data structure that stores
            % boundary conditon definition vectors. The boundary conditons vectors 
            % should be created with specialized methods as e.g. gridd.dirichletBC.
            %
            % See also 
            % pde.setBoudaryCondition
            
            % (c) 2013 Uwe Prüfert 
            switch nargin
                case 1
                    throw(obj.wrongNumberOfBoundaryConditions);
                case 2
                    % one for all
                    bound = varargin{1};
                    for k = 2:obj.nBoundarySegments 
                        k1 = size(bound,2);
                        k2 = size(varargin{1},2);
                        bound(:,k1+1:k1+k2) =  varargin{1};    
                    end
                    obj.b = bound;
                    n = size(obj.b,2);  
                otherwise
                    % every segment must have an entry
                    if obj.nBoundarySegments == nargin-1
                        bound = varargin{1};
                        for k = 2:length(varargin) 
                            k1 = size(bound,2);
                            k2 = size(varargin{k},2);
                            bound(1:size(varargin{k},1),k1+1:k1+k2) = varargin{k};    
                        end
                        obj.b = bound;
                        n = size(obj.b,2);  
                    else
                        fprintf(['Number of boundary segements is ',...
                            num2str(nargin-1),',\n']);
                        fprintf(['but must be ',...
                            num2str(obj.nBoundarySegments),'\n']);
                        obj.wrongNumberOfBoundaryConditions.throwAsCaller;
                    end
            end                      
            if obj.nBoundarySegments~=n     
                throw(obj.wrongNumberOfBoundaryConditions);
            end
        end
        
        function b = dirichletBC(obj,h,r)
            %
            % dirichletBC 
            % 
            % IN:self,char[,char] OUT: double 
            %
            % Method that codes a Diichlet boundary condition 
            %
            % Arguments are h (optional) and r.
            % If used with one argument, $h=1$ is assumed. However, there may be
            % application where the user want to set $h$ to another value. 
            %
            % Note that dirichletBC defines "real" Dirichet boundary conditions, not
            % stiff spring approximation of Dirichlet BCs by Robin BCs.
            %
            % Call:
            %
            %     b = gridd.dirichletBC('0')
            %
            %     b = gridd.dirichletBC('1','0')
            %
            %     b = gridd.dirichletBC('sin(s)')
            %
            %     b = gridd.dirichletBC('x.^2+y.^2')
            %
            %     b = gridd.dirichletBC('myfun(x,y)')
            %
            %     b = gridd.dirichletBC(1)
            %

            %% dirichletBC 
            % 
            % IN:self,char[,char] OUT: double 
            %
            % Method that codes the boundary condition 
            %
            % $$h\,y = r$$
            %
            % Arguments are h (optional) and r.
            % If used with one argument, $h=1$ is assumed. However, there may be
            % application where the user want to set $h$ to another value. 
            %
            % Note that dirichletBC defines "real" Dirichet boundary conditions, not
            % stiff spring approximation of Dirichlet BCs by Robin BCs.
            %
            % Call:
            %
            %     b = gridd.dirichleBC  % to formally define a BC
            %
            %     b = gridd.dirichletBC('0')
            %
            %     b = gridd.dirichletBC('1','0')
            %
            %     b = gridd.dirichletBC('sin(s)')
            %
            %     b = gridd.dirichletBC('x.^2+y.^2')
            %
            %     b = gridd.dirichletBC('myfun(x,y)')
            %
            %     b = gridd.dirichletBC(1)
            %
            
            switch nargin
                case 1
                    b = obj.boundaryCondition([],[],'0','0'); 
                case 2                   
                    switch class(h)
                        case 'double'
                            h = num2str(h);
                        case 'char'
                            % ok
                        otherwise
                            throw(obj.wrongClass)
                    end
                    b = obj.boundaryCondition([],[],'1',h);  
                case 3
                    switch class(h)
                        case 'double'
                            h = num2str(h);
                        case 'char'
                            % ok
                        otherwise
                            throw(obj.wrongClass)
                    end
                    switch class(r)
                        case 'double'
                            h = num2str(r,8); % 8-digits
                        case 'char'
                            % ok
                        otherwise
                            obj.wrongClass.throwAsCaller;
                    end
                    b = obj.boundaryCondition([],[],h,r);
                otherwise
                    obj.wrongNumberInputs.throwAsCaller;
            end
        end
        
        function b = neumannBC(obj,g)
            %
            %  neumannBC 
            %
            %  IN:self,char OUT: double 
            %
            % Mehod that codes Neumann boundary condition.
            %
            % Call:
            %
            %     b = gridd.neumanBC('1')
            %
            %     b = gridd.neumanBC('sin(s)')
            %
            %     b = gridd.neumanBC('x.^2+y.^2')
            %
            %     b = gridd.neumanBC('myfun(x,y)')
            %
            %     b = gridd.neumanBC(1)
            %
            % The argument must be an evaluable term, where the indepented variables
            % must be x,y,z, (if applicable)  or s (arclenght parameter, only 2D).
            %

            %% neumannBC
            % IN:self,char OUT: double 
            %
            % Mehod that codes the boundary condition
            %%
            % $$\vec{n}\cdot\nabla (c\cdot y) = g$$
            %
            % Call:
            %
            %     b = gridd.neumanBC('1')
            %
            %     b = gridd.neumanBC('sin(s)')
            %
            %     b = gridd.neumanBC('x.^2+y.^2')
            %
            %     b = gridd.neumanBC('myfun(x,y)')
            %
            %     b = gridd.neumanBC(1)
            %
            % The argument must be an evaluable term, where the indepented variables
            % must be x,y,z, (if applicable)  or s (arclenght parameter, only 2D).
            %
            b = robinBC(obj,0,g);
        end
        
        function b = robinBC(obj,q,g)
            %
            % robinBC 
            % 
            % IN:self,char,char OUT: double   
            %
            % Method that codes Robin boundary condition.   
            %
            % Arguments are q and g.
            %
            % Call:
            %
            %     b = obj.robinBC('0')
            %
            %     b = obj.robinBC('1','0')
            %
            %     b = obj.robinBC('0','sin(s)')
            %
            %     b = obj.robintBC('1','x.^2+y.^2')
            %
            %     b = obj.robinBC('myfun1(s)','myfun2(x,y)')
            %
            %     b = obj.robinBC(1e3,0)
            %   

            %% robinBC
            %  IN:self,char,char OUT: double   
            %
            % Method that codes the boundary condition   
            % $\vec{n}\nabla \cdot ( c\cdot y) + q = g$.
            % Arguments are q and g.
            %
            % Call:
            %
            %     b = obj.robinBC('0')
            %
            %     b = obj.robinBC('1','0')
            %
            %     b = obj.robinBC('0','sin(s)')
            %
            %     b = obj.robintBC('1','x.^2+y.^2')
            %
            %     b = obj.robinBC('myfun1(s)','myfun2(x,y)')
            %
            %     b = obj.robinBC(1e3,0)
            %

            
            switch nargin
                case 1
                    b = obj.boundaryCondition();
                case 2 
                    switch class(q)
                        case 'double'
                            q = num2str(q);
                        case 'char'
                            % ok
                        otherwise
                            throw(obj.wrongClass)
                    end
                    b = obj.boundaryCondition(q);                    
                case 3
                    switch class(q)
                        case 'double'
                            q = num2str(q);
                        case 'char'
                            % ok
                        otherwise
                            throw(obj.wrongClass)
                    end
                    switch class(g)
                        case 'double'                            
                            g = num2str(g);
                        case 'char'
                            % ok
                        otherwise
                            throw(obj.wrongClass)
                    end
                    b = obj.boundaryCondition(q,g);
                otherwise
                    throw(obj.wrongNumberInputs)
            end
        end   
       
        function val = point2Center(obj,y)
            % point2Center
            % IN self,double OUT: double
            %
            % Method that evaluates a function given at the nodes of the grid at the 
            % centers of every elements. Argument must be a vector of length #points. 
            % The  result is a row vector of length #elements.
            %
            % Call:
            %
            %    y2 = obj.point2Center(y1)
            %  
            
            %% point2Center
            % IN self,double OUT: double
            %
            % Method that evaluates a function given at the nodes of the grid at the 
            % centers of every elements. Argument must be a vector of length #points. 
            % The  result is a row vector of length #elements.
            %
            % Call:
            %
            %    y2 = obj.point2Center(y1)
            %   
            if ~isvector(y)
                obj.wrongFormat.throwAsCaller;
            elseif length(y)==obj.nElements
                MException('GRIDD:OPNOSENSE',...
                    'Size of y is already nElements. Check your code!').throwAsCaller;
            elseif ~length(y)==obj.nPoints
                MException('GRIDD:OPNOSENSE',...
                    'Size of y is not nPoints.').throwAsCaller;             
            end
           
            y = y(:);
 
            switch obj.nPointsInElements
                case 2                       
                   val = 0.5*sum(y(obj.t(1,:))+y(obj.t(2,:)));
                case 3                    
                   val = (y(obj.t(1,:))+ ...
                            y(obj.t(2,:))+ ...
                            y(obj.t(3,:)))/3;
                case 4                    
                   val = 0.25*(y(obj.t(1,:)) + ...
                            y(obj.t(2,:))+ ...
                            y(obj.t(3,:))+ ...
                            y(obj.t(4,:)));
                case 6
                    val =(y(obj.t(1,:)) + ...
                          y(obj.t(2,:)) + ...
                          y(obj.t(3,:)) + ...
                          y(obj.t(4,:)) + ...
                          y(obj.t(5,:)) + ...
                          y(obj.t(6,:)))/6;  
                otherwise
                    MException('PDE:point2Center:UnexpectedNumber',...
                        'Unexpected number of points in element').throw;
            end
            % Row vector
            val = val(:)';
            if length(val)~=obj.nElements
                MException('GRIDD:INTERNAL','You found a bug.').throw;
            end
        end
        
        function val = center2Point(obj,y)
        %% center2Point
        % IN self,double OUT: double
        %
        %
        % Method that evaluates a function given at the 
        % nodes of the grid at the centers of every elements. 
        % Argument must be a vector of length #points. 
        % The result is a row vector of length #elements.
        % 
        % Call:
        % 
        %   y2 = obj.point2Center(y1)

            % (c) 2014 Uwe Prüfert
            if ~isvector(y)
                obj.wrongFormat.throwAsCaller;
            elseif length(y)==obj.nPoints
                MException('GRIDD:OPNOSENSE',...
                    'Size of y is already nPoints. Check your code!').throwAsCaller;
            elseif ~length(y)==obj.nElements
                MException('GRIDD:OPNOSENSE',...
                    'Size of y is not nElements.').throwAsCaller;
            end
            val = obj.center2PointMatrix*(y(:));
            val = val(:)'; % Row vector.
        end
        
        function varargout = nearestPointInGrid(obj,points)
        %%  nearestPointInGrid
        % IN:self,double OUT:double[,double]
        %
        % Method that computes to every point given in argument the point with the
        % smallest distance. The argument must be a matrix of size #space 
        % dimension x n. n >0. Output can be the matrix of points and additional
        % the indeces of points in grid.
        %
        % Call:
        %
        %     val = obj.nearesPointInGrid(p)
        %
        %     [val,indx] = obj.nearesPointInGrid(p)
        
            indx = zeros(size(points,2),1);
            val = zeros(size(points,2),1);
            for k = 1:size(points,2)
                [val(k),indx(k)] = min(sum((obj.p-points(:,k)*ones(1,obj.nPoints)).^2));                 
            end
            switch nargout                
                case 1
                    varargout{1} = indx;
                case 2
                    varargout{1} = val;
                    varargout{2} = indx;
                otherwise
                    % ignore
            end
        end        
        
        function val = midpts(obj)
        %% midpts
        % IN self OUT: double
        % 
        % Method that computes the coordimnates of the centers of 
        % every element, i.e. the barycenters
        % 
        % Call:
        % 
        %    p = obj.midpts
        
        % (c) 2013 by Uwe Prüfert 
            val = obj.p(:,obj.t(1,:))...
                +obj.p(:,obj.t(2,:));
            for k = 3:obj.nPointsInElements
                val =  val+obj.p(:,obj.t(k,:));    
            end
            val = 1/obj.nPointsInElements*val;            
        end
        
        function E = point2CenterMatrix(obj)
            %% point2CenterMatrix
            % IN:self OUT:double
            % 
            % Method that computes the transformation matrix for
            % meshpoint to center of elements transformation. 
            %
            %     y2 = M*y1
            % 
            % is the same as 
            %
            %     y2 = obj.point2Center(y1)
            %
            % Call:
            %
            %     val = obj.point2CenterMatrix
            % 
            % Works only for linear FE exactly. Overwrite it for P2-elements etc. 
            % It is useful if you want to switch between L1-L0 FEs.
            % 
            idx1 = reshape(obj.t(1:obj.nPointsInElements,:),1,obj.nElements*obj.nPointsInElements);
            idx2 = reshape(repmat(1:obj.nElements,obj.nPointsInElements,1),...
                1,obj.nElements*obj.nPointsInElements);           
            E = sparse(idx2,idx1,ones(1,obj.nPointsInElements*obj.nElements),...
                obj.nElements,obj.nPoints)/obj.nPointsInElements;            
        end          
        
        function E = center2PointMatrix(obj)
            %% center2PointMatrix
            % IN:self OUT:double
            % 
            % Returns the transformation matrix barycenters to nodes. Uses linear interpoaltion.
            % Call:  
            %   val = obj.center2PointMatrix
            %
            %  
            idx1 = reshape(obj.t(1:obj.nPointsInElements,:),...
                1,obj.nElements*obj.nPointsInElements);
            idx2 = reshape(repmat(1:obj.nElements,obj.nPointsInElements,1),...
                1,obj.nElements*obj.nPointsInElements); 
        
            E = sparse(...
                idx2,...
                idx1,...
                reshape(ones(obj.nPointsInElements,1)*ones(1,obj.nElements),1,obj.nPointsInElements*obj.nElements),...
                obj.nElements,obj.nPoints)';
            E = sparse(1:obj.nPoints,1:obj.nPoints,1./sum(E,2))*E;            
        end
        
        function setBoundarySegmentNumber(obj,indx,number,varargin)
            %% setBoundarySegemntNumber
            % IN:self,double,double[,char]
            % 
            % Sets the number of the elements in indx to number. 
            %
            % Call
            %   obj.setBoundarySegmentNumber(indexOfBoundaryElements,...
            %                                  NewNumber,...
            %                                  ['force'])
            %  
            % 'force' ignores the existing numbering. Otherwise, a new
            % segment will be created if NewNumber already exists.
            %
            if isempty(indx)
                % Nothing to do
                return
            end
            
            force = false;
            % Handle additional parameters
            switch length(varargin)
                case 1
                    if strcmp(varargin{1},'force')
                        force = true;
                    end                        
                otherwise
            end   
            
            % Some tests
            numbers = unique(obj.e(5,:));
            if max(numbers)~=obj.nBoundarySegments
                warning('gridd: Warning: Boundary numbering inconsistent.\n');
            end
            
            if ~isscalar(number)||number~=round(number)||number<=0
                obj.wrongFormat.throwAsCaller;
            end
            
            numbersAlreadyGiven = unique(obj.t(end,:));
            if ismember(number,numbersAlreadyGiven)&&~force
                % number is already given, we chose another one                
                warning(['The number ',num2str(number),' was already given',...
                    ' Set it to ',num2str(number+1),'.'])
                number = max(numbersAlreadyGiven)+1;
            end
            obj.e(end,indx) = number;
            
        end
        
        function setSubdomainNumber(obj,indx,number,varargin)
            %% setSubdomainNumber
            % IN: self,double|logical,double[,char] OUT.self
            %
            % Method that sets the subdomain number to a user defined value.
            %
            % In OOPDE, every element has a subdomain number (similar to the boundary
            % segment number of edges). By default it is set to one. Using this method,
            % you can set it to user defined values to define subdomains, where, for
            % instance, coefficient functions have different  values. 
            % Arguments are indeces of elements, the subdomain number and the optinal
            % argument 'force'.
            % indx is a vector of class logical with length obj.nElements or a
            % vector of class double with length <= obj.nElements wich 
            % gives the number of elements to be marked. max(indx) must be
            % smaller than obj.nElements  
            % Set 'force' to force a numbering, i.e. if you wish to reset a
            % subdomain setting. 
            %
            % Call:
            %
            %       obj.setSubdomainNumber(1:22,2)
            %
            %       obj.setSubdomainNumber(indx,1,'force')
            %
            %       obj.setSubdomainNumber([true true false true],2)
            %
           
            if isempty(indx)
                % Nothing to do
                return
            end
           
            force = false;
            % Handle additional parameters
            switch length(varargin)
                case 1
                    if strcmp(varargin{1},'force')
                        force = true;
                    end                        
                otherwise
            end            
            
            if length(indx)>obj.nElements
                obj.wrongFormat.throwAsCaller;
                % Cannot be more elements as in mesh 
            end
            
            if isa(indx,'logical')&&length(indx)~=obj.nElements                
                obj.wrongFormat.throwAsCaller;
                % In this case it mus have the same size
            end
            
            if isnumeric(indx)&&max(indx)>obj.nElements
                MException('gridd:index',...
                    'Index must be in range of 1..nElements.').throwAsCaller;
            end
          
            if ~isscalar(number)||number~=round(number)||number<=0
                obj.wrongFormat.throwAsCaller;
            end
            
            numbersAlreadyGiven = unique(obj.t(end,:));
            if ismember(number,numbersAlreadyGiven)&&~force
                % number is already given, we chose another one                
                warning(['The number ',num2str(number),' was already given',...
                    ' Set it to ',num2str(number+1),'.'])
                number = max(numbersAlreadyGiven)+1;
            end
            obj.t(end,indx) = number;
        end
        
        function val = chi(obj,N)
            % chi
            % IN: double OUT: double
            %
            % This method implements an indicator function on the elements of the grid.
            % Gives back a vector of length obj.nElements where value is one if the 
            % elements belongs to subdomain number N and zero otherwise. 
            % 
            % Call:
            %
            %    val = obj.chi(2)
            % 
            % for setting val to one on subdomain 2 and to zero on all
            % other subdomains.
            
            %% chi
            % IN: double OUT: double
            %
            % This method implements an indicator function on the elements of the grid.
            % Gives back a vector of length obj.nElements where value is one if the 
            % elements belongs to subdomain number N and zero otherwise. In mathematical
            % sense, it represents
            % $\chi_{\Omega_N}(x)$.
            % 
            % Call:
            %
            %    val = obj.chi(2)
            % 
            % for setting val to one on subdomain 2 and to zero on all
            % other subdomains.
            
            
            val = double(obj.t(end,:)==N);
        end
        
        function refineUniformly(obj,refines)
            %% refineUniformly
            %
            % IN:double OUT:self
            % 
            % Refines the mesh N times uniformly.
            % 
            % Call:
            %
            %       obj.refineUniformly(3)
            %
            % to refime the mesh three times.
            switch nargin
                case 1
                    n = 1;
                case 2
                    n = refines;
                otherwise
                    obj.wrongNumberInputs.throwAsCaller;
            end
            for k = 1:n
                obj.refineMesh;
            end
        end
        
        function rotateMesh(obj,varargin)
            % rotateMesh 
            % IN:self,cdouble[,double,double,double] OUT:self
            % 
            % Method that rotates the points of a mesh. The method makes
            % only sense if the dimension of the object is 2 or 3. In 2D,
            % the argument is the rotation angle (positive means 
            % counter-clockwise). In 3D, the first three arguments are
            % coordinates of the rotation axis (as vector from the origing)
            % and the fourth argument is the rotation angle.
            %
            % Call
            % 
            %       obj.rotateMesh(alpha)
            %       obj.rotateMesh(n1,n2,n3,alpha)
            %       obj.rotateMesh(x0,y0,z0,n1,n2,n3,alpha)
            %
            % Example
            %
            %       obj.rotateMesh(0,0,1,pi/4)
            %
            % rotates a 3D object around the z axis.
            
            %% rotateMesh 
            % IN:self,cdouble[,double,double,double] OUT:self
            % 
            % Method that rotates the points of a mesh. The method makes
            % only sense if the dimension of the object is 2 or 3. In 2D,
            % the argument is the rotation angle (positive means 
            % counter-clockwise). In 3D, the first three arguments are
            % coordinates of the rotation axis (as vector from the origing)
            % and the fourth argument is the rotation angle.
            %
            % Call
            % 
            %       obj.rotateMesh(alpha)
            %       obj.rotateMesh(n1,n2,n3,alpha)
            %       obj.rotateMesh(x0,y0,z0,n1,n2,n3,alpha)
            %
            % Example
            %
            %       obj.rotateMesh(0,0,1,pi/4)
            %
            % rotates a 3D object around the z axis with angle
            % $\alpha = \pi/4$
            
            if isempty(obj.p)
                % nothing to do
                MException('GRIDD:SENSELESSACTION',...
                    'You try to rotate a empty grid.').throwAsCaller;
            end
            switch obj.spaceDimension
                case 1
                    MException('GRIDD:SENSELESSOPERATION',...
                        'It is not possible to rotate 1D objects.').trowAsCaller;
                case 2
                    switch length(varargin)
                        case 1 % only rotate around (0,0)
                            a = mod(varargin{1},2*pi);           
                            RX = [cos(a) -sin(a)
                                  sin(a)  cos(a)];

                            obj.p = RX*obj.p;  
                        case 3 % rotate around point (x0,y0)
                            % move object in (0,0)
                            obj.moveMesh(-varargin{1},-varargin{2})
                             
                            
                            a = mod(varargin{3},2*pi);                      
                            % rotation matrix
                            RX = [cos(a) -sin(varargin{3})
                                  sin(a)  cos(varargin{3})];
                            
                            % rotate object
                            obj.p = RX*obj.p;  
                            
                            % move back to (x0,y0)
                            obj.moveMesh(varargin{1},varargin{2})
                        otherwise
                            obj.wrongNumberInputs.throwAsCaller;
                    end                     
                    
                case 3
                    switch length(varargin)
                        case 4   
                            % normalize vector
                            n1 = varargin{1}/norm([varargin{1},varargin{2},varargin{3}]);
                            n2 = varargin{2}/norm([varargin{1},varargin{2},varargin{3}]);
                            n3 = varargin{3}/norm([varargin{1},varargin{2},varargin{3}]);                     

                            a = mod(varargin{4},2*pi);                      
                            % rotation matrix
                            RN = [n1^2*(1-cos(a))+cos(a)        n1*n2*(1-cos(a))-n3*sin(a)  n1*n3*(1-cos(a))+n2*sin(a)  
                                  n2*n1*(1-cos(a))+n3*sin(a)    n2^2*(1-cos(a))+cos(a)      n2*n3*(1-cos(a))-n1*sin(a)  
                                  n3*n1*(1-cos(a))-n2*sin(a)    n3*n2*(1-cos(a))+n1*sin(a)  n3^2*(1-cos(a))+cos(a)];
                            % rotate
                            obj.p = RN*obj.p;
                        case 7
                            % bring it to (0,0,0)
                            obj.moveMesh(-varargin{1},-varargin{2},-varargin{3})
                            
                            % normalize vector
                           
                            n1 = varargin{4}/norm([varargin{4},varargin{5},varargin{6}]);
                            n2 = varargin{5}/norm([varargin{4},varargin{5},varargin{6}]);
                            n3 = varargin{6}/norm([varargin{4},varargin{5},varargin{6}]);                     

                            a = mod(varargin{7},2*pi);                      
                            % rotation matrix
                            RN = [n1^2*(1-cos(a))+cos(a)        n1*n2*(1-cos(a))-n3*sin(a)  n1*n3*(1-cos(a))+n2*sin(a)  
                                  n2*n1*(1-cos(a))+n3*sin(a)    n2^2*(1-cos(a))+cos(a)      n2*n3*(1-cos(a))-n1*sin(a)  
                                  n3*n1*(1-cos(a))-n2*sin(a)    n3*n2*(1-cos(a))+n1*sin(a)  n3^2*(1-cos(a))+cos(a)];
                            % rotate
                            obj.p = RN*obj.p;
                            obj.moveMesh(varargin{1},varargin{2},varargin{3})
                        otherwise
                            obj.wrongNumberInputs.throwAsCaller;
                    end
                    %
            end            
        end 
      
        function moveMesh(obj,varargin)
            %% moveMesh 
            % IN:self, double, double, double
            %
            % Moves mesh in direction v.  
            % v must be a vector of length obj.spaceDimension.
            % 
            % In a second form the arguments is a list of dx dy dz, where
            % the number of arguments must coincine with the 
            % dimension of the space. 
            % Call
            %
            %   obj.moveMesh(v)
            % or
            %   obj.moveMesh(dx,dy,dz) %3D
            %   obj.moveMesh(dx,dy) %2D
            %   obj.moveMesh(dx) %1D
            %
            switch obj.spaceDimension
                case 1                    
                    if nargin==2
                        obj.p(1,:) = obj.p(1,:)+varargin{1};                        
                    else
                        obj.wrongFormat.throwAsCaller;
                    end
                case 2
                    if nargin == 2 && length(varargin{1}) == 2                       
                        obj.p(1,:) = obj.p(1,:)+varargin{1}(1);
                        obj.p(2,:) = obj.p(2,:)+varargin{1}(2);  
                    elseif nargin == 3
                        obj.p(1,:) = obj.p(1,:)+varargin{1};
                        obj.p(2,:) = obj.p(2,:)+varargin{2}; 
                    else
                        obj.wrongFormat.throwAsCaller;
                    end 
                                     
                case 3
                    if nargin == 2 && length(varargin{1}) == 3  
                        obj.p(1,:) = obj.p(1,:)+varargin{1}(1);
                        obj.p(2,:) = obj.p(2,:)+varargin{1}(2);
                        obj.p(3,:) = obj.p(3,:)+varargin{1}(3);
                    elseif nargin == 4
                        obj.p(1,:) = obj.p(1,:)+varargin{1};
                        obj.p(2,:) = obj.p(2,:)+varargin{2};
                        obj.p(3,:) = obj.p(3,:)+varargin{3};
                    else
                        obj.wrongFormat.throwAsCaller; 
                    end  
                otherwise
                    MException('GRIDD:UNKNOWNERROR','This should never hapen.')
            end
        end
        
        function scaleMesh(obj,scale)
            %% scaleMesh
            % IN scaleFactor OUT:self
            %
            % This method scales up or down the geometry.
            %
            % Example:
            %
            %   grid = UnitSquare(0.1)
            %   grid.scale(2)
            %
            % produces the square (0,2)x(0,2).
            %
            % ScaleFactor can be a scalar double between 1e-3 and 1e3.
            
            if scale>1e-3 && scale < 1e3
                obj.p = obj.p*scale;
            else
                MException('GRIDD:WRONGPARAMETER',...
                    'Scale factor too small or to large.').throwAsCaller;
            end
        end
    
        function u2 = interpolate(obj,p1,p2,u1)
            %% interpolate
            %
            % IN:double,double,double OUT:double
            %
            % Method that interpolates data from points points.
            %
            % Call
            %        u2 = interpolate(p1,p2,u1)
            % 
            % p1 is a the p field of an grid object with associated data u1.
            % p2 is a p field of a further grid object.
            %
            %
            
            dim = size(p1,1);
            switch dim
                case 1
                    u2 = interp1(p1,u1,p2,'linear');
                case {2,3}  
                    u1 = u1(:); % force to be a column vector
                    if length(u1)==size(p1,2) 
                        interpolant = scatteredInterpolant(p1',u1,'linear','none');
                        u2 = interpolant(p2');
                        u2 = u2(:)';  
                    else
                        MException('GRIDD:WRONGFORMAT',...
                        'Input has the wrong format, check it.').throwAsCaller
                    end
                otherwise
                    % ME werfen...
                    MException('PDE:NOTSUPPORTEDDIM',...
                        'PDE supports only FE in 1D-3D domains').throwAsCaller;
            end

            % remove points not in the domain,
            
% % %             u2(~obj.isPointInDomain(p2)) = NaN;
        end
        
        function val = getBoundaryPoints(obj)
            %% getBoundaryPoints
            % IN self OUT double
            %
            % Call
            %
            %    boundaryPoints = obj.getBoundaryPoints
            % 
            % Gives back the point on the boundary of a grid but
            % excludes the extended points.
            
            % (c) 2013 by Uwe Prüfert
            switch obj.spaceDimension
                case 1
                    val = obj.p(:,unique(obj.e(1,:)));
                case 2
                    val = obj.p(:,unique(obj.e(1:2,:)));
                case 3
                    val = obj.p(:,unique(obj.e(1:3,:)));
                otherwise
            end            
        end
        
        function idx = getBoundaryElementsIndex(obj,boundarySegment)
            %% getBoundaryElementsIndex 
            % IN: self,double OUT:double
            %
            % Returns the indeces of boundary segment of the given boundary
            % segment number.
            % Call
            %
            %   indx = obj.getBoundaryElementsIndex(2)
            %
            % Retuns all boundary elements that belongs to segment number
            % two.
            
            idx = find(obj.e(5,:)==boundarySegment);
        end

        function val = point2CenterB(obj,y)
            %%  point2CenterB 
            % 
            % IN:self,double OUT double  
            %
            % Evaluates the data y(x) on the center of the boundary
            % elements by linear interpolation.
            % point2Center for on the boundary
            % In contrast to midpointsOfBoundaryElements, this method
            % retuns a row vector of lenght obj.nEdges
            
            % Check data y            
            if isvector(y)&&length(y)~=obj.nPoints
                MException('GRIDD:WRONGDATAFORMAT',...
                    'Data y must  have nPoints rows.').throwAsCaller;
            else
                y = y(:); % Make column vector.
            end
            
            if ismatrix(y)&&size(y,1)~=obj.nPoints
                 MException('GRIDD:WRONGDATAFORMAT',...
                    'Data y must  have nPoints rows.').throwAsCaller;

            end
            
            switch obj.spaceDimension
                case 1
                    % Nothing to do, more or less dummy implementation                      
                    MException('GRIDD:NOTVALID',...
                        'This method makes no sense for 1D grids').throwAsCaller;                                    
                case 2
                    indexOfPoints = obj.e(1:2,:);                    
                    val = 0.5*(y(indexOfPoints(1,:),:)+y(indexOfPoints(2,:),:));                    
                case 3
                    % Triangle faces
                    val = zeros(obj.nEdges,1);
                    indexOfPoints = obj.e(1:3,obj.e(4,:)==0);
                      
                    val(obj.e(4,:)==0) = 1/3*(y(indexOfPoints(1,:),:)...
                                            + y(indexOfPoints(2,:),:)...
                                            + y(indexOfPoints(3,:),:));
                    % Rectangle faces
                    indexOfPoints = obj.e(1:4,obj.e(4,:)~=0);
                    val(obj.e(4,:)~=0) = 0.25*(y(indexOfPoints(1,:),:)...
                                            +y(indexOfPoints(2,:),:)...
                                            +y(indexOfPoints(3,:),:)...
                                            +y(indexOfPoints(4,:),:)); 
            end 
            val = val(:)';
        end
        
        function val = midpointsOfBoundaryElements(obj,boundarySegment)
        %%  midpointsOfBoundaryElements 
        % IN: self, double OUT: double
        % 
        % gives back coordinates of center of boundary elements of k-th
        % boundary segment.
        %
        %     val = obj.midpointsOfBoundaryElements([numberOfBoundarySegment])
        %
        % val is a matrix of dimension N x number of boundary elements or  N x
        % number boundary elements of k-th boundary segment(s).
            switch nargin
                case 1
                    boundarySegment = unique(obj.e(5,:));
                case 2
                    if isempty(intersect(boundarySegment,unique(obj.e(5,:))))
                        MException('GRIDD:ARGUMENTSMISSMATCH',...
                            ['The boundary segment',...
                            num2str(numberOfBoundarySegment),...
                            ' do not exist']).throwAsCaller
                    end
            end
            val = [];
            for k = 1:length(boundarySegment)
                elementsOfSegment = (obj.e(5,:)==boundarySegment(k));
                switch obj.spaceDimension
                    case 1
                        indexOfPoints = obj.e(1,elementsOfSegment);
                        val = obj.p(:,indexOfPoints(1,:));
                    case 2
                        indexOfPoints = obj.e(1:2,elementsOfSegment);
                        val = [val 0.5*(obj.p(:,indexOfPoints(1,:))+obj.p(:,indexOfPoints(2,:)))]; %#ok<AGROW>
                    case 3
                        indexOfPoints = obj.e(1:3,elementsOfSegment);
                        val = [val 1/3*(obj.p(:,indexOfPoints(1,:))+obj.p(:,indexOfPoints(2,:))+obj.p(:,indexOfPoints(3,:)))]; %#ok<AGROW>
                end
            end  
        end

        function index= getBoundaryPointsIndex(obj,boundarySegment)
            %%  getBoundaryPointsIndex 
            % IN self,double OUT double
            %
            % Gives back the index of the points on the boundary of a grid.
            %
            % Call 
            %
            %    index= obj.getBoundaryPointsIndex([2 5])
            %
            % returns the indeces of all points in boundary segmens two and
            % five.
            % Note that in contrast to 
            %
            %   getBoundaryPointsIndexPerElement
            %
            % the result is a vector. 
            
            
            % (c) 2013 by Uwe Prüfert
            
            switch nargin
                case 1
                    boundarySegment = unique(obj.e(5,:));
                case 2
                    if isempty(intersect(boundarySegment,unique(obj.e(5,:))))
                        MException('GRIDD:ARGUMENTSMISSMATCH',...
                            ['The boundary segment ',...
                            num2str(boundarySegment),...
                            ' do not exist']).throwAsCaller
                    end
            end
            
            index = obj.getBoundaryPointsIndexPerElement(boundarySegment);
            index = unique(index);
        end
      
        function index= getBoundaryPointsIndexPerElement(obj,boundarySegment)
            %% getBoundaryPointsIndexPerElement
            % IN self,double OUT double
            %
            % Gives back the index of the points on the boundary of a grid.
            %
            % Call 
            %
            %    index= obj.getBoundaryPointsIndexPerElement([2 5])
            %
            % returns the indeces of all points in boundary segmens two and
            % five.
            %
            % Note that the result is a matrix of size number points in
            % boundary elements x number of boundary elements in the 
            % boundary segments the method is called for.
            
            index = [];
            switch nargin
                case 1
                    boundarySegment = unique(obj.e(5,:));
                case 2
                    if isempty(intersect(boundarySegment,unique(obj.e(5,:))))
                        MException('GRIDD:ARGUMENTSMISSMATCH',...
                            ['The boundary segment ',...
                            num2str(boundarySegment),...
                            ' do not exist']).throwAsCaller
                    end
            end
            for k = 1:length(boundarySegment)
                switch obj.spaceDimension
                    case 1
                         index = [index obj.e(1,obj.e(5,:)==boundarySegment(k))]; %#ok<AGROW>
                    case 2
                        if obj.isExtended
                            index = [index obj.e([1 2 6],obj.e(5,:)==boundarySegment(k))]; %#ok<AGROW>
                        else
                            index = [index obj.e(1:2,obj.e(5,:)==boundarySegment(k))]; %#ok<AGROW>
                        end
                    case 3
                         index = [index obj.e(1:3,obj.e(5,:)==boundarySegment(k))]; %#ok<AGROW>
                    otherwise
                end
            end
        end
        
        function index = getBoundaryPointsIndexPerSegment(obj,boundarySegment)
            %% getBoundaryPointsIndexPerSegment
            % IN self,double OUT double
            %
            % Gives bach the index of boundary points of the boundary
            % segment given by the parameter bs.
            % 
            % Call
            %   
            %  index= obj.getBoundaryPointsIndex(2)
            %
            % Returns the points that belong to segment number 2.
            % 
            % Note that if the argument can be a vector.
            % In this case, the index of boundary points of all selected
            % boundary segments are returned, and if there are neighbored
            % bioundary segments, points may occure twice in the list. This
            % is not a bug. 
            % Note that the list of indeces is blockwise sorted. 
            %
            index = [];
            for k = 1:length(boundarySegment)
                index = [index unique(obj.getBoundaryPointsIndexPerElement(boundarySegment(k)))'];
            end
        end

        function index= getInnerPointsIndex(obj)
            %% getInnerPointsIndex 
            % IN:self OUT:double
            %
            % Gives back the index of the points not on the boundary of a grid.
            %
            % Call
            %
            % 
            %   index = obj.getInnerPointsIndex
            
            % (c) 2013 by Uwe Prüfert

            index = 1:obj.nPoints;
            index(obj.getBoundaryPointsIndex) = [];
        end       
    end
    
    methods(Access = public,...
          Abstract = true)
        [sideLength,area] = sideLengthAndArea(obj); % okay for 1D 2D        
    end
    
    methods(Access = private)
        function b = boundaryCondition(obj,q,g,h,r)
            % Defines boundary condition matrix in PDEtool style
            % Syntax:
            % b = obj.boundaryCondition            homogenious Neumann BCs  
            % b = obj.boundaryCondition(g)         Neumann BCs
            % b = obj.boundaryCondition(q,g)       Robin BCs 
            % b = obj.boundaryCondition([],[],h,r) Dirichlet BC
            %
            % (c) 2013 by Uwe Prüfert 
            
            % handle the "minimalistic syntax" options
            switch nargin                 
                case 1
                    q = '0';
                    g = '0';
                    h = [];
                    r = [];
                case 2  
                    g =  q;
                    q = '0';
                    h = [];
                    r = [];
                case 3 
                    h = [];
                    r = [];    
                case 5 
                    if ~(((isempty(g)&&isempty(q))&& ~(isempty(h)&&isempty(r)))||...
                            (~(isempty(g)&&isempty(q))&& (isempty(h)&&isempty(r))))
                        ME = MException('obj:WRONGDEFINITION',...
                            'You can define only Dirichlet OR Robin BCs.');
                        throw(ME);
                    end
                otherwise
                    throw(obj.wrongNumberInputs)
            end
            if isa(g,'double')
                g = num2str(g);
            end
            if isa(q,'double')
                q = num2str(q);
            end
            if isa(r,'double')
                r = num2str(r);
            end
            if isa(h,'double')
                h  = num2str(h);
            end
            if isempty(h)&&isempty(r)
                b = 1;                       % only Neumann BCs
                b(2,1) = 0;
                b(3,1) = length(q);
                b(4,1) = length(g);
                b=[b;double(q)';double(g)'];
            elseif isempty(q)&&isempty(g)   % Dirichlet BCs, setting the Neumann part  
                b = 1;                       % to zero
                b(2,1) = 1;
                b(3,1) = 1;
                b(4,1) = 1;
                b(5,1) = length(h);
                b(6,1) = length(r);
                b(7,1) = 48;
                b(8,1) = 48;
                b = [b;double(h)';double(r)'];    
            end
        end 
    end
    
    methods(Access = public,...
            Hidden = true) 
        % all methods from handle
        % intended not to shown...
         addlistener(obj)
         ge(obj)
         le(obj)
         ne(obj)
         notify(obj)
         gt(obj)
         eq(obj)
         findobj(obj)
         findprop(obj)
         lt(obj)            
    end
end
##### SOURCE END #####
--></body></html>